///////////////////////////////////////////////////////////////////////////////
//                              Lisaac Example                               //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name     := TETRIS;
  
  - comment  := "The TETRIS game";
  
  - author   := "Benoit Sonntag (bsonntag@loria.fr)";

  - version  := 1;
  
Section Inherit  
  
  + parent_area:Expanded AREA;
  
  + parent_g_expr:Expanded G_EXPR;
  
Section Private
  
  - level:UINTEGER_8;
  - line_count:UINTEGER_32;
  
  - face:FAST_ARRAY3[INTEGER];
  
  - screen:FAST_ARRAY2[UINTEGER_8];
  
  - face_to_color n:UINTEGER_8 :UINTEGER_32 <-
  ( + result:UINTEGER_32;

    n
    .when 1 then { result := 02020E0h; }  // Blue.
    .when 2 then { result := 0E07020h; }  // Orange.
    .when 3 then { result := 0E0E020h; }  // Yellow.
    .when 4 then { result := 020E0E0h; }  // Cyan.
    .when 5 then { result := 0E02020h; }  // Red.
    .when 6 then { result := 0E020E0h; }  // Magenta.
    .when 7 then { result := 020E020h; }; // Green.
    result
  );
  
  - case_busy (x,y:INTEGER) face n:UINTEGER_8 <-
  ( + x0,y0:INTEGER;
    + col:UINTEGER_32;
    x0 := x * 25;
    y0 := y * 25;
    col := face_to_color n;
    // Fill.
    rectangle_fill (x0+1,y0+1) to (x0+23,y0+23) color col;    
    // More light.
    line_v (x0,y0+23) until y0 color (col + 1F1F1Fh);
    line_h_until (x0+24);
    // More dark.
    line_v_until (y0+24) color (col - 1F1F1Fh);
    line_h_until x0;    
  );
    
  - delete_line <-
  ( + x,y:INTEGER;
    
    y := 18;
    {
      x := 0;
      {(x < 10) && {screen.item (x,y) != 0}}.while_do {
        x := x+1;
      };
      (x = 10).if {
        y.downto 1 do { yy:INTEGER;
          0.to 9 do { xx:INTEGER;
            screen.put (screen.item (xx,yy-1)) to (xx,yy);
          };
        };
        line_count := line_count + 1;
        (((line_count % 10) = 0) && {level < 19}).if {
          level := level + 1;
        };
        refresh;
      } else {
        y := y-1;
      };
    }.do_while {y != 0};
  );
  
  - load_face p:INTEGER <-
  //  0 |  1  |  2  |  3  |  4  |  5  |  6  |
  //----|-----|-----|-----|-----|-----|-----|
  //  1 |     |     |     |     |     |     |
  //  2 | 3 1 | 2   | 3   |   2 |     | 2   |
  //  X | X   | X 1 | X   | X 1 | X 1 | X 1 |
  //  3 | 2   | 3   | 2 1 | 3   | 2 3 |   3 |
  ( + tmp:BOOLEAN;
    + tmp1,tmp2:INTEGER;
    
    // First graph.
    face.put ((p!=0).to_integer)      to (0,1,0);
    face.put ((p-2)*(p<4).to_integer) to (0,1,1);
    tmp1:=((p&1)<<1)-1;
    face.put ((p=4).to_integer) to (0,2,0);
    face.put tmp1               to (0,2,1);    
    tmp:=(p>4);
    tmp2:=tmp.to_integer;
    face.put tmp2                           to (0,3,0);
    face.put (-tmp1*(!tmp).to_integer+tmp2) to (0,3,1);
    
    // 3 rotation (+pi/2).
    1.to 3 do { r:INTEGER;      
      0.to 3 do { c:INTEGER;
        tmp1 := r - 1;
        face.put (-face.item (tmp1,c,1)) to (r,c,0);  // x' = -y
        face.put (+face.item (tmp1,c,0)) to (r,c,1);  // y' = +x
      };      
    };    
  );

  - pos_r:INTEGER;
  
  - pos_x:INTEGER;
  
  - pos_y:INTEGER;
  
  - n_face:UINTEGER_8;
  
  - move (x,y:INTEGER) rotation r:INTEGER :BOOLEAN <-
  ( + j,px,py:INTEGER;
    
    j:=0;
    {
      (j < 4) && 
      {(px:=x + face.item (r,j,0)).in_range 0 to 9}  &&
      {(py:=y + face.item (r,j,1)).in_range 0 to 18} &&
      {screen.item (px,py) = 0}
    }.while_do {
      j := j + 1;
    };
    (j = 4).if {
      pos_x := x;
      pos_y := y;
      pos_r := r;
    }
  );
  
  - put_face <-
  ( + x,y:INTEGER;
    0.to 3 do { j:INTEGER;
      x := pos_x + face.item (pos_r,j,0);
      y := pos_y + face.item (pos_r,j,1);
      screen.put n_face to (x,y);
    };
  );

  - remove_face <-
  ( + x,y:INTEGER;
    
    0.to 3 do { j:INTEGER;
      x := pos_x + face.item (pos_r,j,0);
      y := pos_y + face.item (pos_r,j,1);
      screen.put 0 to (x,y);    
    };
  );
  
Section Public  
  
  //
  // Width / Height
  //
  
  - width_min:INTEGER  := 25 * 10;
  
  - height_min:INTEGER := 25 * 19 + 14;
  
  //
  // Creation.
  //  
  
  - init:G_EXPR <-
  (
    // Initialization.
    face  :=FAST_ARRAY3[INTEGER]  .create (4,4,2);
    screen:=FAST_ARRAY2[UINTEGER_8].create (10,19);
    tmp_string:=STRING.create 80;    
    stat  := 2;
    random := 015AAC005h;
    G_RAW.create (Self.fix_height.fix_width)
  );
  
  - run:G_WIN_OUT <-
  ( 
    G_WIN_OUT.create "Tetris" with init
  );
  
  - main <-
  (     
    // Init window.
    VIDEO.make (300,520);
    DESK.make VIDEO with (
      G_OUT.create "Tetris" justify (G_OUT.center) / init      
    );        
  );
  
  //
  // Update position.
  //
  
  - set_position rac:AREA at (x,y:INTEGER) size (w,h:INTEGER) <-
  ( 
    update rac from (x,y) size (w,h);
  );
  
  //
  // Display.
  //
  
  - tmp_string:STRING;
  
  - draw (x0,y0:INTEGER) to (x1,y1:INTEGER) <-  
  ( + n:UINTEGER_8;
    + xx,yy:INTEGER;
    
    clipping (x0,y0) to (x1,y1);
    
    // Game array.
    0.to 18 do { y:INTEGER;
      0.to 9 do { x:INTEGER;
        n := screen.item (x,y);
        (n = 0).if {
          xx := x * 25;
          yy := y * 25;
          rectangle_fill (xx,yy) to (xx+24,yy+24) color black;	  
        } else {
          case_busy (x,y) face n;
        };
      };
    };
    
    // Game info.
    rectangle_fill (0,475) to (249,475+13) color gray;
    color black;
    tmp_string.copy "Level:";    
    level.append_in tmp_string format 2 with '0';
    tmp_string.append " Lines:";
    line_count.append_in tmp_string format 4 with '0';    
    stat
    .when 0 to 1 then { tmp_string.append " Play"; }
    .when 2 then { tmp_string.append " Stop";  }
    .when 3 then { tmp_string.append " Pause"; };
    print tmp_string to (2,474);
  );

  - display_face <-
  ( + x0,y0,x1,y1:INTEGER;
    
    x0:=((pos_x - 3).max  0) * 25;
    x1:=(((pos_x + 3).min  9) * 25) + 24;
    y0:=((pos_y - 3).max  0) * 25;
    y1:=(((pos_y + 3).min 18) *25) + 24;
    draw (x0,y0) to (x1,y1);
  );
  
  //
  // Events.
  //
  
  - receive msg:EVENT <-
  ( + evt_keyboard:EVENT_KEYBOARD;
    + evt_time:EVENT_TIMER;
    + evt_mouse:EVENT_MOUSE;
    
    evt_keyboard ?= msg;    
    (evt_keyboard != NULL).if {
      keyboard_event (evt_keyboard.key);
    };
    
    evt_mouse ?= msg;
    (evt_mouse != NULL).if {
      mouse_event evt_mouse;
    };
    
    evt_time ?= msg;    
    (evt_time != NULL).if {
      timer_event evt_time;
    };    
  );
  
  - delay:UINTEGER_32;
  - stat:UINTEGER_8;
  - old_stat:UINTEGER_8;
  - random:UINTEGER_32;
  
  - timer_event evt:EVENT_TIMER <-
  ( + speed:UINTEGER_32;    
    
    ia;
    
    delay := delay + evt.delay;
    speed := 10 - (level >> 1); 
    (delay > speed).if {
      delay := delay - speed;
      stat
      .when 0 then {
        // Stat #0 : Load new face.
        //random := random * random + evt.count;
        
        random := 6.random_upper;
        
        n_face := /*`(2)`:INTEGER;*/ (random % 7).to_uinteger_8; 
        load_face n_face;
        n_face := n_face + 1;
        (move (4,2) rotation 0).if {
          stat := 1;
          put_face;
          display_face;
        } else {
          // Game over.
          stat := 2;
          refresh;
        };
      }
      .when 1 then {
        // Stat #1 : Moving bottom face.
        remove_face;
        (move (pos_x,pos_y+1) rotation pos_r).if {
          put_face;
          display_face;
        } else {
          stat := 0;
          put_face;	  
          delete_line;
        };
      }.when 2 to 3 then {	
        // Stat #2, #3 : Nothing (Stop or Pause game).	
      };
    };
  );
  
  - keyboard_event key:UINTEGER_16 <-
  (
    (((key & 0800h) != 0) && {stat=1}).if {
      remove_face;
      (key & 0FFh).to_character
      .when 'U' then {
        // Rotation.
        move (pos_x,pos_y) rotation ((pos_r+1) & 3);
      }
      .when 'R' then {
        // Right.
        move (pos_x+1,pos_y) rotation pos_r;
      }
      .when 'L' then {
        // Left.
        move (pos_x-1,pos_y) rotation pos_r;
      }
      .when 'D' then {
        // Speed Down.
        {move (pos_x,pos_y+1) rotation pos_r}.while_do {
          put_face;
          display_face;
          remove_face;
        };
      };
      put_face;
      display_face;
    } else {
      ((key & 0FFh).to_character = ' ').if {
        (stat = 2).if {
          // New game.
          screen.clear_all;
          line_count := stat := 0;
          level := 19;
        }.elseif {stat = 3} then {
          // Restart (after pause).
          stat := old_stat;
        } else {
          // Pause.
          old_stat := stat;
          stat := 3;
        };
        refresh;
      };
    };
  );

  - mouse_event evt:EVENT_MOUSE <-
  ( + win:AREA;
    
    win := DESK.get_object (evt.x_current,evt.y_current);
    (win != Self).if {
      // Pause.
      (stat < 2).if {
        old_stat := stat;      
        stat := 3;	
        refresh;
      };
      DESK.receive evt;
    } else {
      (evt.left_down).if {
        (stat = 2).if {
          // New game.
          screen.clear_all;
          line_count := stat := 0;
          level := 19;
        }.elseif {stat = 3} then {
          // Restart (after pause).
          stat := old_stat;
        } else {
          // Pause.
          old_stat := stat;
          stat := 3;
        };
        refresh;
      };
    };
  );
  
  //
  // IA
  //
  
  - form:FAST_ARRAY3[INTEGER] := FAST_ARRAY3[INTEGER].create (4,4,2);
  
  - screen_ia:FAST_ARRAY2[BOOLEAN] := FAST_ARRAY2[BOOLEAN].create (10,19);
  
  - stat_ia:INTEGER;
  
  - ia <-
  ( + cnt,dx,dy,tmp,px,py,max,x,y:INTEGER;
    + first,is_ok:BOOLEAN;
    - px_max,pr_max:INTEGER;
    
    // Copy game.
    0.to 18 do { cy:INTEGER; 
      0.to 9 do { cx:INTEGER;          
        screen_ia.put (screen.item (cx,cy) != 0) to (cx,cy);
      };
    };
    /*
    17.to 18 do { cy:INTEGER;
      0.to 9 do { cx:INTEGER;
        screen_ia.put TRUE to (cx,cy);
      };
    };
    screen_ia.put FALSE to (5,17);
    screen_ia.put FALSE to (5,18);      
    */
    (stat_ia = 0).if {          
      // Detect face.      
      dx := dy := 10;
      y := 0;
      {(cnt != 4) && {y < 4}}.while_do {
        x := 3;
        {(cnt != 4) && {x < 7}}.while_do {
          (screen_ia.item (x,y) != 0).if {          
            dx := dx.min x;
            dy := dy.min y;
            form.put x to (0,cnt,0);
            form.put y to (0,cnt,1);
            cnt := cnt + 1;
          };
          x := x + 1;
        };
        y := y + 1;
      };
      (cnt = 4).if {
        //"Face detect!\n".print;
        // Normalize.
        0.to 3 do { i:INTEGER;
          form.put (form.item (0,i,0)-dx) to (0,i,0);
          form.put (form.item (0,i,1)-dy) to (0,i,1);
        };
        // 3 rotation (+pi/2).
        1.to 3 do { r:INTEGER;      
          dx := dy := 10;
          px_max := pr_max := 10;
          0.to 3 do { c:INTEGER;
            tmp := r - 1;
            px := -form.item (tmp,c,1);
            py := +form.item (tmp,c,0);
            dx := dx.min px;
            dy := dy.min py;
            ((py < pr_max) || {(py = pr_max) && {px < px_max}}).if {
              pr_max := py;
              px_max := px;
              max := c;              
            };              
            form.put px to (r,c,0);  // x' = -y
            form.put py to (r,c,1);  // y' = +x
          };      
          (max != 0).if {
            // Swap for 0 is always first point.
            tmp := form.item (r,0,0);
            form.put (form.item (r,max,0)) to (r,0,0);
            form.put tmp to (r,max,0);
            tmp := form.item (r,0,1);
            form.put (form.item (r,max,1)) to (r,0,1);
            form.put tmp to (r,max,1);
          };
          // Normalize.
          0.to 3 do { i:INTEGER;
            form.put (form.item (r,i,0)-dx) to (r,i,0);
            form.put (form.item (r,i,1)-dy) to (r,i,1);
          };
        };    
        //print_form;
        // Evaluation.
        result_list.clear;        
        0.to 3 do { pr:INTEGER;
          px := 0;
          {
            is_ok := mesure pr pos px;            
            px := px + 1;
          }.do_while {is_ok};
        };
        (pr_max,px_max) := choice_best;
        /*
        "Rotation : ".print;
        pr_max.print;
        " pos_x : ".print;
        px_max.print; '\n'.print;
        */
        //IO.read_character;
        
        1.to pr_max do { i:INTEGER;
          keyboard_event (0800h | 'U'.to_integer);
        };
        
        stat_ia := 1;
        //"Position...\n".print;
      };      
    }.elseif {stat_ia = 1} then {
      // Game.      
      y := 0;
      {(!first) && {y < 19}}.while_do {
        x := 0;
        {(!first) && {x < 10}}.while_do {
          (screen_ia.item (x,y)).if {
            px := x - form.item (pr_max,0,0);
            (px = px_max).if {
              keyboard_event (0800h | 'D'.to_integer);
              stat_ia := 2;
              //"Wait...\n".print;      
            } else {
              1.to (px - px_max) do { t:INTEGER; 
                keyboard_event (0800h | 'L'.to_integer);
              };
              1.to (px_max - px) do { t:INTEGER;
                keyboard_event (0800h | 'R'.to_integer);
              };
            };
            first := TRUE;
          };          
          x := x + 1;
        };
        y := y + 1;
      };
    }.elseif {stat_ia = 2} then {
      // Wait other face.      
      y := 0;
      {(cnt != 4) && {y < 4}}.while_do {
        x := 3;
        {(cnt != 4) && {x < 7}}.while_do {
          (screen_ia.item (x,y) != 0).if {                      
            cnt := cnt + 1;
          };
          x := x + 1;
        };
        y := y + 1;
      };
      (cnt != 4).if {
        stat_ia := 0;
        "Detect...\n".print;
      };
    };
  );
  
  - screen_after:FAST_ARRAY2[BOOLEAN] := FAST_ARRAY2[BOOLEAN].create (10,19);
  
  - result_list:FAST_ARRAY[INTEGER] := FAST_ARRAY[INTEGER].create_with_capacity (40*5);
  
  - mesure pr:INTEGER pos px:INTEGER :BOOLEAN <-
  ( + py,m0,m1,m2,j:INTEGER;
    + r0,r1,r2:INTEGER;
    + result,stop,add_ok:BOOLEAN;
    
    py := put_ia pr pos px;                           
    (py != -1).if {
      // Evaluation.
      screen_after.copy screen_ia;
      m0 := mesure_line screen_after;
      m1 := mesure_hole screen_after;
      m2 := mesure_flat screen_after;
      /*
      pr.print; ','.print;
      px.print; ':'.print;
      m0.print; ' '.print;      
      m1.print; ' '.print;
      m2.print; '\n'.print;
      */
      
      j := result_list.lower;
      {(j <= result_list.upper) && {! stop}}.while_do {
        r0 := result_list.item j;
        r1 := result_list.item (j+1);
        r2 := result_list.item (j+2);        
        (
          (
            (m0 < r0) && {m1 > r1} && {m2 > r2}
          ) || {
            (m0 <= r0) && {m1 = r1} && {m2 = r2}
          } || {
            (m0 = r0) && {m1 > r1} && {m2 = r2}
          } || {
            (m0 = r0) && {m1 = r1} && {m2 > r2}
          }
        ).if {
          // Bad solution.
          add_ok := TRUE;
          stop := TRUE;
        }.elseif {
          (
            (m0 > r0) && {m1 < r1} && {m2 < r2}
          ) || {
            (m0 >= r0) && {m1 = r1} && {m2 = r2}
          } || {
            (m0 = r0) && {m1 < r1} && {m2 = r2}
          } || {
            (m0 = r0) && {m1 = r1} && {m2 < r2}
          }
        } then {
          // Best solution.
          (add_ok).if {
            result_list.remove j to (j+4);
          } else {
            result_list.put m0 to j;
            result_list.put m1 to (j+1);
            result_list.put m2 to (j+2);
            result_list.put pr to (j+3);
            result_list.put px to (j+4);          
            add_ok := TRUE;
            j := j + 5;
          };
        } else {
          j := j + 5;
        };
      };      
      (add_ok).if_false {
        result_list.add_last m0;
        result_list.add_last m1;
        result_list.add_last m2;
        result_list.add_last pr;
        result_list.add_last px;
      };      
      /*
      print_result 0;
      IO.read_character;
      */
      // Remove.
      remove_ia pr pos (px,py);        
      result := TRUE;
    };                        
    result
  );
  
  - min_value:BOOLEAN <- FALSE;
  - max_value:BOOLEAN <- TRUE;
  
  - choice_best:(INTEGER,INTEGER) <-
  ( + base_hole,base_flat,lev,idx:INTEGER;
    //+ is_l:BOOLEAN;
    
    base_hole := mesure_hole screen_ia;
    //is_l := detect_l;
    base_flat := mesure_flat screen_ia;
    lev := 18-mesure_ymax screen_ia;
    ((lev < 6) && {base_hole < 2} && {base_flat < 10}).if {
      // 1:hole, 2:flat, 3:line.
      idx := get_best (1,min_value) and (2,min_value) and (0,max_value);
    } else {
      idx := -1;
      //(base_flat >= 10).if {
        // 1:line, 2:hole (with flat <= base_flat), 3:flat.
        idx := get_best_flat (base_flat,base_hole);
        (idx != -1).if {
          "------------- FLAT --------------\n".print;
        };
      //};
      (idx = -1).if {
        // 1:line, 2:hole, 3:flat.
        //idx := get_best (1,min_value) and (0,max_value) and (2,min_value);
        idx := get_best_line base_hole;
      };
    };
    "Base flat : ".print; base_flat.print; '\n'.print;
    print_result base_hole;
    "Best : ".print; (idx/5).print; '\n'.print;
    result_list.item (idx+3),result_list.item (idx+4)
  );  
  
  - get_best (c0:INTEGER,max0:BOOLEAN) 
  and (c1:INTEGER,max1:BOOLEAN) 
  and (c2:INTEGER,max2:BOOLEAN) :INTEGER <-
  ( + result:INTEGER;
    + best0,best1,best2:INTEGER;
    + tmp0,tmp1,tmp2:INTEGER;
    + is_good:BOOLEAN;
        
    best0 := result_list.item c0;
    best1 := result_list.item c1;
    best2 := result_list.item c2;
    (result_list.lower+5).to (result_list.upper) by 5 do { i:INTEGER;
      tmp0 := result_list.item (i+c0);
      tmp1 := result_list.item (i+c1);
      tmp2 := result_list.item (i+c2);
      is_good := FALSE;
      (best0 = tmp0).if {
        (best1 = tmp1).if {
          is_good := ((max2) && {best2 < tmp2}) || {(! max2) && {best2 > tmp2}};
        } else {
          is_good := ((max1) && {best1 < tmp1}) || {(! max1) && {best1 > tmp1}};          
        };
      } else {
        is_good := ((max0) && {best0 < tmp0}) || {(! max0) && {best0 > tmp0}};
      };
      (is_good).if {      
        best0 := tmp0;
        best1 := tmp1;
        best2 := tmp2;
        result := i;        
      };
    };
    result
  );  
  
  - get_best_flat (base_flat,base_hole:INTEGER) :INTEGER <-
  ( + result:INTEGER;
    + best0,best1,best2:INTEGER;
    + tmp0,tmp1,tmp2:INTEGER;
    + is_good:BOOLEAN;
    
    result := -1;
    best0 := 0;
    best1 := 100_000; 
    best2 := 100_000; 
    (result_list.lower).to (result_list.upper) by 5 do { i:INTEGER;
      tmp0 := result_list.item (i+0);
      tmp1 := result_list.item (i+1);
      tmp2 := result_list.item (i+2);
      is_good := FALSE;      
      (best0 = tmp0).if {
        (tmp2+(tmp1-base_hole)+1 < base_flat).if {
          (best1 = tmp1).if {
            is_good := best2 > tmp2;
          } else {
            is_good := best1 > tmp1;          
          };
        };
      } else {
        is_good := best0 < tmp0;
      };
      (is_good).if {      
        best0 := tmp0;
        best1 := tmp1;
        best2 := tmp2;
        result := i;        
      };
    };
    result
  );  
  
  - get_best_line base_hole:INTEGER :INTEGER <-
  ( + result:INTEGER;
    + best0,best1,best2:INTEGER;
    + tmp0,tmp1,tmp2:INTEGER;
    + is_good:BOOLEAN;
    
    best0 := 0;
    best1 := 100_000;
    best2 := 100_000;
    (result_list.lower).to (result_list.upper) by 5 do { i:INTEGER;
      tmp0 := result_list.item (i+0);
      tmp1 := result_list.item (i+1);
      tmp2 := result_list.item (i+2);
      is_good := FALSE;      
      (best0 = tmp0).if {    
        (best1 = tmp1).if {
          is_good := best2 > tmp2;
        } else {
          is_good := best1 > tmp1;          
        };
      } else {
        is_good := (best0 < tmp0) && {(tmp0 > 1) || {tmp1<=base_hole}};
      };
      (is_good).if {      
        best0 := tmp0;
        best1 := tmp1;
        best2 := tmp2;
        result := i;        
      };
    };
    result
  );  
    
  - put_ia r:INTEGER pos x:INTEGER :INTEGER <-
  ( + j,px,py,y:INTEGER;
    + in:BOOLEAN;
    
    y := 3;
    {
      j := 0;
      y := y + 1;
      {
        (j < 4) && 
        {in := ((px:=x + form.item (r,j,0)).in_range 0 to 9)}  &&
        {(py:=y + form.item (r,j,1)).in_range 0 to 18} &&
        {! screen_ia.item (px,py)}
      }.while_do {
        j := j + 1;
      };      
    }.do_while {j = 4};
    (! in).if {      
      y := -1;
    } else {      
      y := y - 1;
      0.to 3 do { i:INTEGER;
        px := x + form.item (r,i,0);
        py := y + form.item (r,i,1);
        screen_ia.put TRUE to (px,py);
      };
    };
    y
  );
  
  - remove_ia r:INTEGER pos (x,y:INTEGER) <-
  ( + px,py:INTEGER;
    0.to 3 do { i:INTEGER;
      px := x + form.item (r,i,0);
      py := y + form.item (r,i,1);
      screen_ia.put FALSE to (px,py);
    };
  );
  
  //
  // Sub-routine mesure.
  //
/*  
  - detect_l:BOOLEAN <-
  ( + x,y:INTEGER;
    + result:BOOLEAN;
    
    x := form.item (0,0,0);
    y := form.item (0,0,1);
    (
      ((x = form.item (0,2,0)) && {(x = form.item (0,1,0)) || {x = form.item (0,3,0)}}) ||
      {(y = form.item (0,2,1)) && {(y = form.item (0,1,1)) || {y = form.item (0,3,1)}}}
    ).if {
      result := TRUE;
    } else {
      x := form.item (0,1,0);
      y := form.item (0,1,1);
      result := (
        ((x = form.item (0,2,0)) && {x = form.item (0,3,0)}) ||
        {(y = form.item (0,2,1)) && {y = form.item (0,3,1)}}
      );
    };
    result      
  );
  */
  /*  
  - mesure_bar tab:FAST_ARRAY2[BOOLEAN] :INTEGER <-
  ( + result:INTEGER;
    
    
  );
  */
  
  - mesure_ymax tab:FAST_ARRAY2[BOOLEAN] :INTEGER <-
  ( + result,x:INTEGER;
    
    result := 4;
    {
      x := 0;
      {(x < 10) && {! tab.item (x,result)}}.while_do {
        x := x + 1;
      };
      result := result + 1;
    }.do_while {(result < 19) && {x = 10}};
    result - 1
  );
  
  - mesure_hole tab:FAST_ARRAY2[BOOLEAN] :INTEGER <-
  ( + result:INTEGER;
    + y:INTEGER;
    
    0.to 9 do { x:INTEGER;
      y := 4;
      {(y < 19) && {!tab.item (x,y)}}.while_do {
        y := y + 1;
      };
      {y < 19}.while_do {
        (! tab.item (x,y)).if {
          result := result + 1;
        };
        y := y + 1;
      };
    };
    result
  );
  
  - mesure_line tab:FAST_ARRAY2[BOOLEAN] :INTEGER <-
  ( + result:INTEGER;
    + y,x:INTEGER;
    
    y := 18;
    {
      x := 0;
      {(x < 10) && {tab.item (x,y)}}.while_do {
        x := x + 1;
      };
      (x = 10).if {
        y.downto 5 do { yy:INTEGER;
          0.to 9 do { xx:INTEGER;
            tab.put (tab.item (xx,yy-1)) to (xx,yy);
          };
        };
        result := result + 1;
      } else {
        y := y - 1;
      };
    }.do_while {y != 4};
    result
  );
  
  - mesure_flat tab:FAST_ARRAY2[BOOLEAN] :INTEGER <-
  ( + py,y_min,y_max,y,tmp:INTEGER;
    + result:INTEGER;
    
    py := 3;      
    {
      py := py + 1;        
    }.do_while {(py < 19) && {! tab.item (0,py)}};                 
    y_min := y_max := py;    
    //
    1.to 9 do { px:INTEGER;
      y := 3;
      {
        y := y + 1;        
      }.do_while {(y < 19) && {! tab.item (px,y)}};        
      tmp := (y-py).abs;
      result := result + tmp; // * tmp;
      y_max := y_max.max y;
      y_min := y_min.min y;
      py := y;
    };
    tmp := y_max - y_min;
    //result := result + tmp * tmp;
    result
  );
  
  //
  // Debug.
  //
  
  - screen_txt:FAST_ARRAY2[CHARACTER] := FAST_ARRAY2[CHARACTER].create (4*5*2,4);
  
  - print_form <-
  ( + px,py:INTEGER;
    screen_txt.set_all_with '-';
    0.to 3 do { r:INTEGER;      
      px := (r*5+form.item (r,0,0)) * 2;
      py := form.item (r,0,1);
      screen_txt.put '(' to (px,py);
      screen_txt.put ')' to (px+1,py);
      1.to 3 do { p:INTEGER;
        px := (r*5+form.item (r,p,0)) * 2;
        py := form.item (r,p,1);
        screen_txt.put '[' to (px,py);
        screen_txt.put ']' to (px+1,py);
      };            
      0.to 3 do { y:INTEGER;
        px := (r*5+4)*2;
        screen_txt.put ' ' to (px,y);
        screen_txt.put ' ' to (px+1,y);
      };
    };    
    0.to 3 do { y:INTEGER;
      0.to 39 do { x:INTEGER;
        screen_txt.item (x,y).print;
      };
      '\n'.print;
    };
  );
  
  - print_screen_ia <-
  (
    0.to 18 do { y:INTEGER;
      0.to 9 do { x:INTEGER;
        (screen_ia.item (x,y)).if {
          "[]".print;
        } else {
          "--".print;
        };
      };
      '\n'.print;
    };    
  );
  
  - print_result base_hole:INTEGER <-
  (
    "|N \t|Line\t|Hole\t|Flat\t||Rot.\t|X   \t|\n".print;
    (result_list.lower).to (result_list.upper) by 5 do { i:INTEGER;
      '|'.print;
      (i/5).print; "\t|".print;
      result_list.item i.print;
      "\t|".print;
      (result_list.item (i+1)-base_hole).print;
      "\t|".print;
      result_list.item (i+2).print;
      "\t||".print;
      result_list.item (i+3).print;
      "\t|".print;
      result_list.item (i+4).print;
      "\t|\n".print;
    };
  );
  
  /* OLD !
  - mesure_old:INTEGER <-
  ( + result,y,x,py,l,y_min,y_max,yyy:INTEGER;
    
    // Compute screen after :
    screen_after.copy screen_ia;
    y := 18;
    {
      x := 0;
      {(x < 10) && {screen_after.item (x,y)}}.while_do {
        x := x+1;
      };
      (x = 10).if {
        y.downto 5 do { yy:INTEGER;
          0.to 9 do { xx:INTEGER;
            screen_after.put (screen_after.item (xx,yy-1)) to (xx,yy);
          };
        };
        l := l + 1;
      } else {
        y := y-1;
      };
    }.do_while {y != 4};
        
    l
    .when 4 then { result := 1000_000; }  // Bingo !
    .when 3 then { result := 0100_000; }  // Good  !
    .when 2 then { result := 0010_000; }  // Idem  !
    .when 1 then { result := 0000_010; };
    
    (l < 2).if {
      result := result + 200;
      py := 3;      
      {
        py := py + 1;        
      }.do_while {(py < 19) && {! screen_after.item (0,py)}};      
      (py+1).to 18 do { i:INTEGER;
        (screen_after.item (0,i)).if_false {
          result := result - 16*4;
        };
      };
      
      y_min := y_max := py;
      result := result + py/3;
      //
      1.to 9 do { px:INTEGER;
        y := 3;
        {
          y := y + 1;        
        }.do_while {(y < 19) && {! screen_after.item (px,y)}};              
        (y+1).to 18 do { i:INTEGER;
          (screen_after.item (px,i)).if_false {
            result := result - 16*4;
          };
        };
        
        result := result - ((y-py).abs * (y-py).abs);
        y_max := y_max.max y;
        y_min := y_min.min y;
        result := result + y/3;        
        py := y;
      };
      (y_min < 14).if {
        result := result - (y_max - y_min)*(y_max - y_min)*(y_max - y_min);
      } else {
        result := result - (y_max - y_min)*(y_max - y_min);
      };
    };
    
    result
  );
*/