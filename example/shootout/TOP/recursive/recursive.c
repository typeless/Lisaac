// C code generated by Lisaac compiler (www.isaacOS.com) //
int arg_count;
char **arg_vector;

//==========================//
// EXTERNAL                 //
//==========================//

// SYSTEM_IO

#include <stdio.h>
#include <stdlib.h>
#include <sys/syscall.h>  
// Hardware 'print_char'
void print_char(char car)
{
  fputc(car,stdout);
}

// Hardware 'exit'
int die_with_code(int code)
{
  exit(code);
}


// SYSTEM
#include <time.h>

//==========================//
// TYPE                     //
//==========================//

// Generic Object
struct ___OBJ {
  unsigned long __id;
};

// NULL
#ifndef NULL
#define NULL ((void *)0)
#endif

// INTEGER__L
typedef int __INTEGER__L;

// RECURSIVE
#define __RECURSIVE__B__ 0
typedef struct RECURSIVE__B_struct __RECURSIVE__B;
struct RECURSIVE__B_struct {
  void *Nothing;
};
// TRUE__C
#define TRUE__C__ 1

// FALSE__J
#define FALSE__J__ 0

// BOOLEAN__D
typedef char __BOOLEAN__D;

// CHARACTER__4
typedef char __CHARACTER__4;

// INTEGER_8__TL
typedef signed char __INTEGER_8__TL;


void *table_type[1];

//==========================//
// GLOBAL                   //
//==========================//

__RECURSIVE__B RECURSIVE__B_;
#define RECURSIVE__B__ (&RECURSIVE__B_)


//==========================//
// FUNCTION HEADER          //
//==========================//

// Source code
static __INTEGER__L ack__YB(__RECURSIVE__B *Self__ZB,__INTEGER__L x__0B,__INTEGER__L y__1B);
static void print_positif__QJ(__INTEGER__L Self__RJ);

//==========================//
// SOURCE CODE              //
//==========================//

int main(int argc,char **argv)
{
  __INTEGER__L __tmp__VB;
  __BOOLEAN__D __tmp__LD;
  arg_count  = argc;
  arg_vector = argv;
#ifdef _PTHREAD_H
  pthread_key_create(&current_thread, NULL);
  pthread_attr_init(&thread_attr);
  /*pthread_attr_setdetachstate(&thread_attr,PTHREAD_CREATE_DETACHED);*/
#endif
  ;
  __tmp__VB=ack__YB(RECURSIVE__B__, 3, 4);
  if ((__tmp__VB ==  0)) {
    fputc((int)('0'),stdout);
    __tmp__LD=TRUE__C__;
  } else {
    __tmp__LD=FALSE__J__;
  };
  if ((! __tmp__LD)) {
    if ((__tmp__VB <  0)) {
      fputc((int)('-'),stdout);
      print_positif__QJ((__INTEGER__L)(- __tmp__VB));
    } else {
      print_positif__QJ(__tmp__VB);
    };
  };
  fputc((int)('\n'),stdout);
  fputc((int)('\n'),stdout);
  return(0);
}


static __INTEGER__L ack__YB(__RECURSIVE__B *Self__ZB,__INTEGER__L x__0B,__INTEGER__L y__1B)
// ({RECURSIVE__B},{INTEGER__L},{INTEGER__L}) With result Recursive, No inlinable.
{
  __INTEGER__L result__3B,__tmp__TC,__tmp__ZC,__tmp__4C,__tmp__AD;
  __INTEGER__L Result__2B;
  __BOOLEAN__D __tmp__FC;
  result__3B= 0;
  if ((x__0B ==  0)) {
    result__3B=(__INTEGER__L)(y__1B +  1);
    __tmp__FC=TRUE__C__;
  } else {
    __tmp__FC=FALSE__J__;
  };
  if ((! __tmp__FC)) {
    if ((y__1B ==  0)) {
      __tmp__TC=ack__YB(Self__ZB,(__INTEGER__L)(x__0B -  1), 1);
      result__3B=__tmp__TC;
    } else {
      __tmp__ZC=(__INTEGER__L)(x__0B -  1);
      __tmp__4C=ack__YB(Self__ZB,x__0B,(__INTEGER__L)(y__1B -  1));
      __tmp__AD=ack__YB(Self__ZB,__tmp__ZC,__tmp__4C);
      result__3B=__tmp__AD;
    };
  };
  Result__2B=result__3B;
  return(Result__2B);
}

static void print_positif__QJ(__INTEGER__L Self__RJ)
// ({INTEGER__L}) Void Recursive, No inlinable.
{
  __INTEGER__L __tmp__4J;
  __CHARACTER__4 Result__LL;
  Result__LL=((__CHARACTER__4 )(((__INTEGER_8__TL)(((__INTEGER_8__TL )(__INTEGER__L)(Self__RJ %  10)) + ((__INTEGER_8__TL )'0')))));
  __tmp__4J=(__INTEGER__L)(Self__RJ /  10);
  if ((__tmp__4J !=  0)) {
    print_positif__QJ(__tmp__4J);
  };
  fputc((int)(Result__LL),stdout);
}
