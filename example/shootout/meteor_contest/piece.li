///////////////////////////////////////////////////////////////////////////////
//                              Lisaac Example                               //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name         := PIECE;
  
  - author       := "Benoit Sonntag";
  - comment      := "Language shootout - Meteor contest (based on the C++ version)"; 
  
Section Inherit
  
  - parent_any:OBJECT := OBJECT;

Section Private
  
  struct Piece {
   struct Instance {
      TUInt64 m_allowed;
      BitVec m_vec;
      int m_offset;
   };

   static const int N_ELEM = 5;
   static const int N_ORIENT = 12;
   static const int ALL_PIECE_MASK = (1 << N_PIECE_TYPE) - 1;
   static const TUInt32 SKIP_PIECE = 5; // it's magic!

   typedef int TPts[N_ELEM][N_DIM];

   static const BitVec BaseVecs[N_PIECE_TYPE];
   static Piece s_basePiece[N_PIECE_TYPE][N_ORIENT];

   static const Instance & getPiece(TUInt32 iPiece, TUInt32 iOrient, TUInt32 iParity);
   static BitVec toBitVector(const TPts & pts);
   static void genOrientation(BitVec vec, TUInt32 iOrient, Piece & target);
   static void setCoordList(BitVec vec, TPts & pts);
   static void shiftUpLines(TPts & pts, int shift);
   static int shiftToX0(TPts & pts, Instance & instance, int offsetRow);
   void setOkPos(TUInt32 isOdd, int w, int h);
   static void genAllOrientations(void);

   Instance m_instance[N_PARITY];
};

  
  Piece Piece::s_basePiece[N_PIECE_TYPE][N_ORIENT];
  
  const BitVec Piece::BaseVecs[] = {
   0x10f, 0x0cb, 0x1087, 0x427, 0x465,
   0x0c7, 0x8423, 0x0a7, 0x187, 0x08f
 };
 
  - set_coord_list (vec:BIT_VEC , TPts & pts) <-
  ( + ipt:INTEGER;
    + mask:BIT_VEC;
    
    mask := 1;
    0.to (n_row-1) do { y:INTEGER;
      0.to (n_col-1) do { x:INTEGER;
	((mask & vec) != 0).if {
	  pts.put x to (ipt,x);
	  pts.put y to (ipt,y);
	  
	  ipt := ipt + 1;
	};
	mask := mask << 1;
      };
    };
  );

  - to_bit_vector (const TPts & pts) :BIT_VEC <-
  ( + y, x:INTEGER;
    + result:BIT_VEC;
    
    0.to (n_elem-1) do { ipt:INTEGER;
      x := pts.item (ipt,x);
      y := pts.item (ipt,y);
      result := result | (1 << BOARD.get_index (x,y));
    };
    result
  );

  - shift_up_lines (TPts & pts, shift:INTEGER) <-
  (
    // vertical shifts have a twist
    0.to (n_elem-1) do { ipt:INTEGER;
      int & rx = pts[iPt][X];
      int & ry = pts[iPt][Y];

      (ry & shift & 0x1).if {
	rx := rx + 1;
      };
      ry := ry - shift;
    };
  );    

  - shift_to_x0(TPts & pts, Instance & instance, offset_row:INTEGER) :INTEGER <-
  (
    // .. determine shift
    + x, y, ipt,offset:INTEGER;
    + x_min:INTEGER; 
    + x_max:INTEGER; 
    
    x_min := pts.item (0,x);
    x_max := x_min;
    
    1.to (n_elem-1) do { ipt:INTEGER;     
      x := pts.item (ipt,x);
      y := pts.item (ipt,y);
      
      (x < x_min).if {
	x_min := x;
      } else {
	(x > x_max).if {
	  x_max := x;
	};
      };
    };
    
    // I'm dying for a 'foreach' here
    offset := n_elem;
    1.to (n_elem-1) do { ipt:INTEGER;     
      int & rx = pts[iPt][X];
      int & ry = pts[iPt][Y];
      
      rx := rx - x_min;
      
      // check offset -- leftmost cell on top line
      ((ry = offset_row) && {rx < offset}).if {
	offset := rx;
      };
    };
    
    instance.m_offset := offset;
    instance.m_vec := to_bit_vector pts;
    x_max - x_min;
  );

  - set_ok_pos (is_odd:UINTEGER_32, w,h:INTEGER) <-
  ( + y,x_pos:INTEGER;
    + piece_vec:BIT_VEC;
    Instance & p = m_instance[isOdd];
    TUInt64 & allowed = p.m_allowed = 0;
    TUInt64 posMask = 1LL << (isOdd * N_COL);
   
    y := is_odd;
    {y < n_row - h}.while_do {      
      (p.m_offset).if {
	pos_mask := pos_mask << p.m_offset;
      };      
      x_pos := 0;
      {x_pos < n_col - p.m_offset}.while_do {
	// check if the new position is on the board
	(x_pos < n_col - w).if {
	  // move it to the desired location
	  piece_vec := p.m_vec << x_pos;

	  (! BOARD.has_bad_islands_single (piece_vec, y)).if {            
	    // position is allowed	    
	    allowed := allowed | pos_mask;
	  };
	};
	x_pos := x_pos + 1;
	pos_mask := pos_mask << 1;	
      }
      y := y + 2;
      pos_mask := pos_mask << n_col;
    };
  );

  - gen_orientation (vec:BIT_VEC , i_orient:UINTEGER_32, Piece & target) <-
  ( + y,x,ipt,rot,flip,x_new,y_new,y_min,y_max,h,w:INTEGER;
    
    // get (x,y) coordinates
    TPts pts;
    set_coord_list (vec, pts);
    
    rot := i_orient % 6;
    flip := i_orient >= 6;
    (flip).if {
      0.to (n_elem-1) do { ipt:INTEGER;
	pts.put (-pts.item (ipt,y)) to (ipt,y);	
      };
    };

    // rotate as necessary
    while (rot--) {
      0.to (n_elem - 1) do { ipt:INTEGER;      
	x := pts.item (ipt,x);
	y := pts.item (ipt,y);

	// I just worked this out by hand. Took a while.
	x_new := floor(2 * x - 3 * y + 1, 4);
        y_new := floor(2 * x + y + 1, 2);
	pts.put x_new to (ipt,x);
	pts.put y_new to (ipt,y);
      };
    };

    // determine vertical shift
    y_min := pts.item (0,y);
    y_max := y_min;
    1.to (n_elem - 1) do { ipt:INTEGER;      
      y := pts.item (ipt,y);
      
      (y < y_min).if {
	y_min := y;
      } else { 
	(y > y_max).if {
	  y_max := y;
	};
      };
    };
    h := y_max - y_min;
    Instance & v_even := target.m_instance.item even;
    Instance & v_odd := target.m_instance.item odd;

    shift_up_lines (pts, y_min);
    w := shift_to_x0 (pts, v_even, 0);
    target.set_ok_pos (even, w, h);
    even.m_vec := even.m_vec >> even.m_offset;

    // shift down one line
    shift_up_lines(pts, -1);
    w := shift_to_x0(pts, v_odd, 1);
    // shift the bitmask back one line
    v_odd.m_vec := v_odd.m_vec >> n_col;
    target.set_ok_pos (odd, w, h);
    v_odd.m_vec := v_odd.m_vec >> v_odd.m_offset;
  );

  - gen_all_orientations <-
  ( + ref_piece:BIT_VEC;
    
    0.to (n_piece_type - 1) do { i_piece:INTEGER;
      ref_piece := base_vecs.item i_piece;
      0.to (n_orient - 1) do { i_orient:INTEGER;
	Piece & p := s_base_piece.item (i_piece,i_orient);
	gen_orientation (ref_piece, i_orient, p);
	((i_piece = skip_piece) && {(i_orient / 3) & 1}).if {
	  p.m_instance.item 0.m_allowed := p.m_instance.item 1.m_allowed := 0;
	};
      };
    };
    
    0.to (n_piece_type - 1) do { i_piece:INTEGER;
      0.to (n_orient - 1) do { i_orient:INTEGER;      
	+ mask:UINTEGER_64;
	mask := 1;
	0.to (n_row - 1) do { i_row:INTEGER;
	  const Instance & p = getPiece(iPiece, iOrient, (iRow & 1));
	  0.to (n_col-1) do { i_col:INTEGER;
	    OK_PIECES & allowed := g_ok_pieces.item (i_row,i_col);
	    (p.m_allowed & mask).if {
	      TInt8 & n_piece := allowed.n_pieces.item i_piece;
	      allowed.piece_vec.item (i_piece,n_piece) := p.m_vec << i_col;
	      n_piece := n_piece + 1;
	    };
	    
	    mask := mask << 1;
	  };
	};
      };
    };
  );
  

inline const Piece::Instance & Piece::getPiece(TUInt32 iPiece, TUInt32 iOrient, TUInt32 iParity) {
   return s_basePiece[iPiece][iOrient].m_instance[iParity];
}
