///////////////////////////////////////////////////////////////////////////////
//                              Lisaac Example                               //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name         := PIECE;
  
  - author       := "Benoit Sonntag";
  - comment      := "Language shootout - Meteor contest (based on the C++ version)"; 
  
Section Inherit
  
  - parent_any:OBJECT := OBJECT;

Section Private
  
  Piece Piece::s_basePiece[N_PIECE_TYPE][N_ORIENT];
  
  const BitVec Piece::BaseVecs[] = {
   0x10f, 0x0cb, 0x1087, 0x427, 0x465,
   0x0c7, 0x8423, 0x0a7, 0x187, 0x08f
 };
 
  - set_coord_list (vec:BIT_VEC , TPts & pts) <-
  ( + ipt:INTEGER;
    + mask:BIT_VEC;
    
    mask := 1;
    0.to (n_row-1) do { y:INTEGER;
      0.to (n_col-1) do { x:INTEGER;
	((mask & vec) != 0).if {
	  pts.put x to (ipt,x);
	  pts.put y to (ipt,y);
	  
	  ipt := ipt + 1;
	};
	mask := mask << 1;
      };
    };
  );

  - to_bit_vector (const TPts & pts) :BIT_VEC <-
  ( + y, x:INTEGER;
    + result:BIT_VEC;
    
    0.to (n_elem-1) do { ipt:INTEGER;
      x := pts.item (ipt,x);
      y := pts.item (ipt,y);
      result := result | (1 << BOARD.get_index (x,y));
    };
    result
  );

  - shift_up_lines (TPts & pts, shift:INTEGER) <-
  (
    // vertical shifts have a twist
    0.to (n_elem-1) do { ipt:INTEGER;
      int & rx = pts[iPt][X];
      int & ry = pts[iPt][Y];

      (ry & shift & 0x1).if {
	rx := rx + 1;
      };
      ry := ry - shift;
    };
  );    

  - shift_to_x0(TPts & pts, Instance & instance, offset_row:INTEGER) :INTEGER <-
  (
    // .. determine shift
    + x, y, ipt,offset:INTEGER;
    + x_min:INTEGER; 
    + x_max:INTEGER; 
    
    x_min := pts.item (0,x);
    x_max := x_min;
    
    1.to (n_elem-1) do { ipt:INTEGER;     
      x := pts.item (ipt,x);
      y := pts.item (ipt,y);
      
      (x < x_min).if {
	x_min := x;
      } else {
	(x > x_max).if {
	  x_max := x;
	};
      };
    };
    
    // I'm dying for a 'foreach' here
    offset := n_elem;
    1.to (n_elem-1) do { ipt:INTEGER;     
      int & rx = pts[iPt][X];
      int & ry = pts[iPt][Y];
      
      rx := rx - x_min;
      
      // check offset -- leftmost cell on top line
      ((ry = offset_row) && {rx < offset}).if {
	offset := rx;
      };
    };
    
    instance.m_offset := offset;
    instance.m_vec := to_bit_vector pts;
    x_max - x_min;
  );

  - set_ok_pos (is_odd:UINTEGER_32, w,h:INTEGER) <-
  (
   Instance & p = m_instance[isOdd];
   TUInt64 & allowed = p.m_allowed = 0;
   TUInt64 posMask = 1LL << (isOdd * N_COL);

   for (int y = isOdd; y < N_ROW - h; y+=2, posMask <<= N_COL) {
      if (p.m_offset)
         posMask <<= p.m_offset;

      for (int xPos = 0; xPos < N_COL - p.m_offset; xPos++, posMask <<= 1) {
         // check if the new position is on the board
         if (xPos >= N_COL - w)
            continue;

         // move it to the desired location
         BitVec pieceVec = p.m_vec << xPos;

         if (Board::hasBadIslandsSingle(pieceVec, y))
            continue;

         // position is allowed
         allowed |= posMask;
      }
   }
}

void Piece::genOrientation(BitVec vec, TUInt32 iOrient, Piece & target)
{
   // get (x,y) coordinates
   TPts pts;
   setCoordList(vec, pts);

   int y, x, iPt;
   int rot = iOrient % 6;
   int flip = iOrient >= 6;
   if (flip) {
      for (iPt = 0; iPt < N_ELEM; iPt++)
         pts[iPt][Y] = -pts[iPt][Y];
   }

   // rotate as necessary
   while (rot--) {
      for (iPt = 0; iPt < N_ELEM; iPt++) {
         x = pts[iPt][X];
         y = pts[iPt][Y];

         // I just worked this out by hand. Took a while.
         int xNew = floor((2 * x - 3 * y + 1), 4);
         int yNew = floor((2 * x + y + 1), 2);
         pts[iPt][X] = xNew;
         pts[iPt][Y] = yNew;
      }
   }

   // determine vertical shift
   int yMin = pts[0][Y];
   int yMax = yMin;
   for (iPt = 1; iPt < N_ELEM; iPt++) {
      y = pts[iPt][Y];

      if (y < yMin)
         yMin = y;
      else if (y > yMax)
         yMax = y;
   }
   int h = yMax - yMin;
   Instance & even = target.m_instance[EVEN];
   Instance & odd = target.m_instance[ODD];

   shiftUpLines(pts, yMin);
   int w = shiftToX0(pts, even, 0);
   target.setOkPos(EVEN, w, h);
   even.m_vec >>= even.m_offset;

   // shift down one line
   shiftUpLines(pts, -1);
   w = shiftToX0(pts, odd, 1);
   // shift the bitmask back one line
   odd.m_vec >>= N_COL;
   target.setOkPos(ODD, w, h);
   odd.m_vec >>= odd.m_offset;
}

void Piece::genAllOrientations(void) {
   for (int iPiece = 0; iPiece < N_PIECE_TYPE; iPiece++) {
      BitVec refPiece = BaseVecs[iPiece];
      for (int iOrient = 0; iOrient < N_ORIENT; iOrient++) {
         Piece & p = s_basePiece[iPiece][iOrient];
         genOrientation(refPiece, iOrient, p);
         if ((iPiece == SKIP_PIECE) && ((iOrient / 3) & 1))
            p.m_instance[0].m_allowed = p.m_instance[1].m_allowed = 0;
      }
   }

   for (int iPiece = 0; iPiece < N_PIECE_TYPE; iPiece++) {
      for (int iOrient = 0; iOrient < N_ORIENT; iOrient++) {
         TUInt64 mask = 1;
         for (int iRow = 0; iRow < N_ROW; iRow++) {
            const Instance & p = getPiece(iPiece, iOrient, (iRow & 1));
            for (int iCol = 0; iCol < N_COL; iCol++) {
               OkPieces & allowed = g_okPieces[iRow][iCol];
               if (p.m_allowed & mask) {
                  TInt8 & nPiece = allowed.nPieces[iPiece];
                  allowed.pieceVec[iPiece][nPiece] = p.m_vec << iCol;
                  nPiece++;
               }

               mask <<= 1;
            }
         }
      }
   }
}


inline const Piece::Instance & Piece::getPiece(TUInt32 iPiece, TUInt32 iOrient, TUInt32 iParity) {
   return s_basePiece[iPiece][iOrient].m_instance[iParity];
}
