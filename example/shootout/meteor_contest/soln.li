///////////////////////////////////////////////////////////////////////////////
//                              Lisaac Example                               //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name         := SOLN;
  
  - author       := "Benoit Sonntag";
  - comment      := "Language shootout - Meteor contest (based on the C++ version)"; 
  
Section Inherit
  
  - parent_any:OBJECT := OBJECT;

Section Private
  
  struct Soln {
   static const int NO_PIECE = -1;

   void setCells(void);
   bool lessThan(Soln & r);
   string toString(void) const;
   void fill(int val);
   void spin(Soln & spun);

   bool isEmpty(void) {return (m_nPiece == 0);}
   void popPiece(void) {m_nPiece--; m_synched = false;}
   void pushPiece(BitVec vec, int iPiece, int row) {
      SPiece & p = m_pieces[m_nPiece++];
      p.vec = vec;
      p.iPiece = (short)iPiece;
      p.row = (short)row;
   }

   Soln(int fillVal);
   Soln() : m_synched(false), m_nPiece(0) {}

   struct SPiece {
      BitVec vec;
      short iPiece;
      short row;
      SPiece() {}
      SPiece(BitVec avec, TUInt32 apiece, TUInt32 arow) :
         vec(avec), iPiece(short(apiece)), row(short(arow))
         {}
   };
   SPiece m_pieces[N_PIECE_TYPE];
   TUInt32 m_nPiece;
   TInt8 m_cells[N_ROW][N_COL];
   bool m_synched;
};

  
Soln::Soln(int fillVal) :
   m_nPiece(0) {
   fill(fillVal);
}

void Soln::fill(int val) {
   m_synched = false;
   memset(m_cells, val, N_CELL);
}

string Soln::toString(void) const {
   string result;
   result.reserve(N_CELL * 2);

   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         int val = m_cells[y][x];
         result += ((val == NO_PIECE) ? '.' : char('0' + val));
         result += ' ';
      }
      result += '\n';

      // indent every second line
      if (y % 2 == 0)
         result += " ";
   }
   return result;
}

  - set_cells <-
  ( + vec:BIT_VEC;
    + pid:INTEGER_8;
    + row_offset,n_new_cells:INTEGER;
    
    (m_synched).if_false {
      0.to (m_n_piece-1) do { i_piece:UINTEGER_32;	
	const SPiece & p = m_pieces[iPiece];
	vec := p.vec;
	pid := p.i_piece.to_integer8;
	row_offset := p.row;

	n_new_cells := 0;
	row_offset.to (n_row - 1) do { y:INTEGER;
	  0.to (n_col-1) do { x:INTEGER;
	    ((vec & 1) != 0).if {
	      m_cells.put pid to (y,x);
	      n_new_cells := n_new_cells + 1;
	    };
	    vec := vec >> 1;
	  };
	  (n_new_cells = PIECE.n_elem).if {
	    break;
	  };
	};
      };
      m_synched := TRUE;
    };
  );
  

  - less_than (Soln & r) :BOOLEAN <-
  ( + result,stop:BOOLEAN;
    + lval,rval,x,y:INTEGER;
    
    (m_pieces.item 0.i_piece != r.m_pieces.item 0.i_piece).if {
      result := m_pieces.item 0.i_piece < r.m_pieces.item 0.i_piece;
    } else {

      set_cells;
      r.set_cells;
      
      y := 0;
      {(y < n_raw) && {! stop}}.while_do { 
	x := 0;
	{(x < n_col) && {! stop}}.while_do { 
	  lval := m_cells.item (y,x);
	  rval := r.m_cells.item (y,x);
	  
	  (lval != rval).if {
	    stop := TRUE;
	    result := (lval < rval);
	  };
	  x := x + 1;
	};
	y := y + 1;
      };
    };
    result
  );

  - spin (Soln & spun) <-
  ( + flipped:INTEGER_8;
    
    set_cells;

    // swap cells
    0.to (n_row - 1) do { y:INTEGER;   
      0.to (n_col - 1) do { x:INTEGER;
	flipped := m_cells.item (n_row - y - 1,n_col - x - 1);
	spun.m_cells.put flipped to (y,x);
      };
    };
    
    // swap first and last pieces (the rest aren t used)
    spun.m_pieces.item 0.i_piece := m_pieces.item (n_piece_type - 1).i_piece;
    spun.m_synched := TRUE;
  );
