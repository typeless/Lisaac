////////////////////////////////////////////////////////////////////////////////
//                           Lisaac Example                                   //
//                                                                            //
//                  LSIIT - ULP - CNRS - INRIA - FRANCE                       //
//                                                                            //
//    This program is free software; you can redistribute it and/or modify    //
//    it under the terms of the CeCILL v2 License as published by the         //
//    CEA - CNRS - INRIA.                                                     //
//                                                                            //
//    This program is distributed in the hope that it will be useful,         //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            //
//    CeCILL v2 License for more details.                                     //
//                                                                            //
//    You should have received a copy of the CeCILL v2 license along with     //
//    this program.                                                           //
//    If not, see <http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt>  //
//                                                                            //
//                    http://isaacproject.u-strasbg.fr/                       //
////////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name := K_NUCLEOTIDE2;
  
Section Inherit
  
  - parent_object:OBJECT := OBJECT;
  
Section Public
  
  - buffer:STRING;
  
  - reader:STRING := STRING.create 0;
  - generate_frequencies (fl:INTEGER, buffer:STRING, buflen:INTEGER) 
  :HASHED_DICTIONARY[FREQ_STRING,INTEGER] <-
  ( + nulled:CHARACTER;
    + result:HASHED_DICTIONARY[FREQ_STRING,INTEGER];
    
    (fl > buflen).if {
      result := NULL;
    } else {
      result := HASHED_DICTIONARY[FREQ_STRING,INTEGER].create; // (hash_table_size (fl, buflen));
      0.to (buflen - fl -1) do { i:INTEGER;
	reader.set_storage (buffer.storage + i);
	reader.set_count (buffer.count - i);
	//reader := &(buffer[i]);
	nulled := reader.item fl;
	reader.put 1 to fl;
	result.at reader.inc_val;	
	reader.put nulled to fl;
      };
    };
    result
  );

  - write_frequencies fl:INTEGER <-
  ( + ht:HASHED_DICTIONARY[FREQ_STRING,INTEGER];    
    + s:FAST_ARRAY[FREQ_STRING];    
    + percent:INTEGER;
 
    ht := generate_frequencies (fl, buffer, buflen);
    
    s := FAST_ARRAY[SORTER].create_with_capacity (ht.count); //size;
    (ht.lower).to (ht.upper) do { j:INTEGER;
      s.add_last (ht.item j); 
    };
    0.to (s.upper) do { i:INTEGER;
      (i + 1).to (s.upper-1) do { j:INTEGER;
	(s.item i.num < s.item j.num).if {
	  s.swap i to j;	
	};
      };
    };
    
    0.to (s.upper) do { i:INTEGER;
      s.item i.string.print;
      ' '.print;
      percent := (100_000 * s.item i.num) / FREQ_STRING.total;
      (percent / 1000).print;
      '.'.print;
      (percent % 1000).print;
      '\n'.print;    
    };
    '\n'.print;
    //ht_destroy (ht);
    //free (s);
  );

  - write_count (search_for:STRING, buffer:STRING, buflen:INTEGER) <-
  ( + ht:HASHED_DICTIONARY[FREQ_STRING,INTEGER];
    
    ht := generate_frequencies (search_for.count, buffer, buflen);
    ht.at search_for.val.print;
    '\t'.print;
    search_for.print;
    '\n'.print;
    // ht_destroy (ht);
  );
  
  - char_tab:FAST_ARRAY[CHARACTER] := FAST_ARRAY[CHARACTER].create_with_capacity 4;
  - letter :FAST_ARRAY[UINTEGER_32] := FAST_ARRAY[UINTEGER_32].create 5;
  - letter2:FAST_ARRAY[UINTEGER_32] := FAST_ARRAY[UINTEGER_32].create 21;
  
  - ggt:INTEGER;
  - ggta:INTEGER;
  - ggtatt:INTEGER;
  - ggtattttaatt:INTEGER;
  - ggtattttaatttatagt:INTEGER;
  
  - string_tmp:STRING := STRING.create 10;
  
  - aff_number (elt,tot:UINTEGER_64) <-
  ( + r:UINTEGER_64;
        
    r := (elt * 100_000) / tot;
    (r / 1000).print;
    '.'.print;
    string_tmp.clear;
    (r % 1000).append_in string_tmp format 3 with '0';
    string_tmp.add_last ' ';
    string_tmp.add_last '(';    
    elt.append_in string_tmp; 
    string_tmp.add_last '/'; 
    tot.append_in string_tmp; 
    string_tmp.add_last ')';        
    string_tmp.print;
  );
  
  - main <-
  ( + old_count:INTEGER;
    + char:CHARACTER;
    + code,old_code:INTEGER;
    + stat2,stat,idx:INTEGER;
    + total:UINTEGER_64;
    
    buffer := STRING.create 10240;
    char_tab.add_last 'A';
    char_tab.add_last 'T';
    char_tab.add_last 'C';
    char_tab.add_last 'G';
    {      
      buffer.clear;
      IO.read_line_in buffer;      
    }.do_until {buffer.has_prefix ">THREE"};
    buffer.clear;
    
    {! IO.end_of_input}.while_do {
      old_count := buffer.count;
      IO.read_line_in buffer;      
    };
        
    buffer.to_upper;
    (buffer.lower).to (buffer.upper) do { j:INTEGER;
      char := buffer.item j;
      
      (char = 'A').if {
	code := 0;
      } else {
	(char = 'C').if {
	  code := 1;
	} else {
	  (char = 'G').if {
	    code := 2;
	  } else {
	    (char = 'T').if {
	      code := 3;
	    } else {
	      code := 4;
	    };
	  };
	};
      };
      letter.put (letter.item code + 1) to code;
      (stat2 = 0).if {
	stat2 := 1;	
      } else {
	idx := (old_code << 2) | code;
	letter2.put (letter2.item idx + 1) to idx;
      };
      old_code := code;
      code
      .when 0 then { // A
	stat
	.when 0 to 2 then {
	  stat := 0;
	}
	.when 3 then {
	  stat := 4;
	  ggta := ggta + 1;
	};
      }
      .when 1 then { // C
	stat := 0;
      }
      .when 2 then { // G
	stat
	.when 0 then { stat := 1; }
	.when 1 then { stat := 2; }
	.when 2 to 6 then {
	  stat := 0;
	};
      }
      .when 3 then { // T
	stat
	.when 0 or 1 then {
	  stat := 0;
	}
	.when 2 then {
	  stat := 3;
	  ggt := ggt + 1;	  
	}
	.when 3 then {
	  stat := 0;
	}
	.when 4 then {
	  stat := 5;
	}
	.when 5 then {
	  stat := 6;
	  ggtatt := ggtatt + 1;
	};
      };
    };
    
    total := letter.first + letter.item 1 + letter.item 2 + letter.item 3;
    'A'.print; ' '.print;
    aff_number (letter.first,total);
    '\n'.print;
    'T'.print; ' '.print;
    aff_number (letter.item 1,total);
    '\n'.print;
    'C'.print; ' '.print;
    aff_number (letter.item 2,total);
    '\n'.print;
    'G'.print; ' '.print;
    aff_number (letter.item 3,total);
    '\n'.print;
    
    '\n'.print;
    0.to 15 do { j:INTEGER;
      char_tab.item (j >> 2).print;
      char_tab.item (j & 11b).print;      
      ' '.print;
      aff_number (letter2.item j,total - 1);
      '\n'.print;
    };
          
    ggt.print; 
    "\tGGT\n".print;
    
    ggta.print; 
    "\tGGTA\n".print;
    
    ggtatt.print; 
    "\tGGTATT\n".print;
    
    ggtattttaatt.print; 
    "\tGGTATTTTAATT\n".print;
    
    ggtattttaatttatagt
    "\tGGTATTTTAATTTATAGT\n".print;
      
  );