////////////////////////////////////////////////////////////////////////////////
//                           Lisaac Example                                   //
//                                                                            //
//                  LSIIT - ULP - CNRS - INRIA - FRANCE                       //
//                                                                            //
//    This program is free software; you can redistribute it and/or modify    //
//    it under the terms of the CeCILL v2 License as published by the         //
//    CEA - CNRS - INRIA.                                                     //
//                                                                            //
//    This program is distributed in the hope that it will be useful,         //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            //
//    CeCILL v2 License for more details.                                     //
//                                                                            //
//    You should have received a copy of the CeCILL v2 license along with     //
//    this program.                                                           //
//    If not, see <http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt>  //
//                                                                            //
//                    http://isaacproject.u-strasbg.fr/                       //
////////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name := KNUCLEOTIDE;
  
Section Public
  

  inherit ABSTRACT_SORTER[TUPLE[INTEGER,STRING]]

  insert ARGUMENTS

Section Public

  - main <-
  (
    create array.make(100000)
    create sequence.make(100000)
    create dictionary.with_capacity(10000)
    read
    write_frequencies 1;
    write_frequencies 2;
    write_count "GGT";
    write_count "GGTA";
    write_count "GGTATT";
    write_count "GGTATTTTAATT";
    write_count "GGTATTTTAATTTATAGT";
  );

  - write_frequencies length:INTEGER <-
  ( + i: INTEGER;
    + coef: REAL_64;
    
    count length;
    array.clear_count;
    dictionary.item_map_in array;
    sort array;
    coef := {INTEGER 100} / (1 + sequence.count - length)    
    i:=array.lower;
    {i>array.upper}.until_do {
      IO.put_string(array.item(i).second)
      IO.put_character(' ')
      IO.put_real_format(coef * array.item(i).first, 3)
      IO.put_character '\n';
      i := i + 1
    };
    IO.put_character '\n';
  );

   write_count(match: STRING) is local n: INTEGER do
      count(match.count)
      tuple := dictionary.reference_at(match)
      if tuple /= Void then n := tuple.first end
      io.put_integer(n)
      io.put_character('%T')
      io.put_string(match)
      io.put_character('%N')
   end

  - sequence:STRING;
  - part: STRING;
  - tuple: TUPLE[INTEGER,STRING];
  - dictionary: HASHED_DICTIONARY[TUPLE[INTEGER,STRING],STRING];
  - array: FAST_ARRAY[TUPLE[INTEGER,STRING]];

  - read <-
  (
     IO.read_line;
     {(IO.end_of_input) || {IO.last_string.has_prefix ">THREE"}}.until_do {
       IO.read_line;
     };
     
     (! IO.end_of_input).if {
         IO.read_line;
	 {(IO.end_of_input) || {IO.last_string.first = '>'}}.until_do {
	   (IO.last_string.first != ';').if {
	     sequence.append (IO.last_string);
	   };
	   IO.read_line;
	 };
	 sequence.to_upper;
       };
     };
   );
     
   - count length:INTEGER <-
   ( + pos, i, j: INTEGER; 

     dictionary.clear_count;
     part := sequence.substring (1,length);
     tuple := [{INTEGER 1}, part.twin]
     dictionary.add tuple to (tuple.second);
     pos := length
     {pos >= sequence.upper}.until_do {
         pos := pos + 1
         i:=1;
	 {i = length}.until_do {
	   j:=i+1;
	   part.put (part.item j) to i; 
	   i:=j; 
	 };
         part.put (sequence.item pos) to length;
         tuple := dictionary.reference_at part;
         (tuple = NULL).if {
            tuple := [{INTEGER 1}, part.twin]
            dictionary.add tuple to (tuple.second);
         } else {
            tuple.set_first (1 + tuple.first);
         };
      };
   );

   lt (a,b: like tuple): BOOLEAN <- 
   (
     (b.first < a.first) || {(a.first = b.first) && {a.second < b.second}}
   );

