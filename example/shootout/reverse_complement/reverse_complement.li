///////////////////////////////////////////////////////////////////////////////
//                              Lisaac Example                               //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name         := REVERSE_COMPLEMENT;
  
  - bibliography := "http://IsaacOS.com";
  - author       := "Xavier Oswald (x.oswald@free.fr)";
  - comment      := "Language shootout - REVERSE-COMPLEMENT";
  
Section Inherit
  
  - parent_any:OBJECT := OBJECT;

Section Public

  - iub_pairs :FAST_ARRAY2[CHARACTER] := FAST_ARRAY2[CHARACTER].create(7,2);
  
  - iub_complement :FAST_ARRAY[CHARACTER] := FAST_ARRAY[CHARACTER].create 256; // 1+UCHAR_MAX -> 255+1

  - strand :STRING;

  - slen :INTEGER;

  - init_iub_pairs <-
  (
    iub_pairs.put 'A'  to (0,0); iub_pairs.put 'T'  to (0,1);
    iub_pairs.put 'C'  to (1,0); iub_pairs.put 'G'  to (1,1);
    iub_pairs.put 'B'  to (2,0); iub_pairs.put 'V'  to (2,1);
    iub_pairs.put 'D'  to (3,0); iub_pairs.put 'H'  to (3,1);
    iub_pairs.put 'K'  to (4,0); iub_pairs.put 'M'  to (4,1);
    iub_pairs.put 'R'  to (5,0); iub_pairs.put 'Y'  to (5,1);
    iub_pairs.put '\0' to (6,0); iub_pairs.put '\0' to (6,1);
  );

  - build_iub_complement <-
  ( + j:INTEGER;

    0.to 256 do { i:INTEGER;
      iub_complement.put (i.to_character) to i;   
    };

    j := 0;
    {iub_pairs.item(j,0) != '\0'}.while_do {
      iub_complement.put(iub_pairs.item(j,1)) to ((iub_pairs.item(j,0)).to_integer); 
      iub_complement.put(iub_pairs.item(j,0)) to ((iub_pairs.item(j,1)).to_integer);
      // suite a voir...
      j := j+1; 
    };
  );

  - in_place_reverse <-
    ( + i:INTEGER;
      + c:CHARACTER;

      i := 0;
      slen := slen - 1;

      {i < slen}.while_do {
        c := strand.item i;
        strand.put(iub_complement.item((strand.item slen).to_integer)) to i;
        strand.put(iub_complement.item(c.to_integer)) to i;
        i := i + 1;
        slen := slen - 1;
      };

      (i = slen).if {
        strand.put(iub_complement.item((strand.item i).to_integer)) to i;
      };
    );

  - process <-
    ( + c :CHARACTER;
      + s :STRING;
      
      in_place_reverse;
      s := strand;

      {slen > 60}.while_do{
        c := s.item 60;
        s.put '\0' to 60;
        s.print;
        //'\n'.print;
        s.put c to 60;
        // s := s + 60; // augmente capacit√©
        slen := slen - 60;
      };

      s.put '\0' to slen;
      //puts(s)
    );

  - main <-
  ( + buffer :STRING;
    + mlen   :INTEGER;
    + l      :INTEGER;
   
    buffer := STRING.create 1024;
    strand := STRING.create 129;

    mlen := 128;
    slen  := 0;

    init_iub_pairs;
    build_iub_complement;

    IO.read_line;
    {IO.end_of_input}.until_do{
      (buffer.item 0 = '>').if{
        (slen > 0).if{
          process;
          slen := 0;
        };
        buffer.print;
      } else {
        l := buffer.count; // size of string (strlen)
        { (l > 0) /* && {!isalpha buffer.item(l-1)}*/}.while_do{
          mlen := mlen + mlen;
          //inp = (char *) realloc (inp, mlen + 1);
        };
        //memcpy (inp + slen, buffer, l);
        slen = l + slen;
        IO.read_line;
      };
    };

    (slen > 0).if{
      process;
    };

  );
