////////////////////////////////////////////////////////////////////////////////
//                           Lisaac Compiler                                  //
//                                                                            //
//                  LSIIT - ULP - CNRS - INRIA - FRANCE                       //
//                                                                            //
//    This program is free software; you can redistribute it and/or modify    //
//    it under the terms of the CeCILL v2 License as published by the         //
//    CEA - CNRS - INRIA.                                                     //
//                                                                            //
//    This program is distributed in the hope that it will be useful,         //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            //
//    CeCILL v2 License for more details.                                     //
//                                                                            //
//    You should have received a copy of the CeCILL v2 license along with     //
//    this program.                                                           //
//    If not, see <http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt>  //
//                                                                            //
//                    http://isaacproject.u-strasbg.fr/                       //
////////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name        := NODE_TYPE;
  
  - author      := "Sonntag Benoit (bsonntag@loria.fr)";
  - comment     := "Switch node for type";
    
Section Inherit
  
  + parent_node:Expanded NODE;
  
Section Public
    
  - result_expr:EXPR <- data.result_expr;
  
  + is_self:BOOLEAN;
  
  //
  // Creation.
  //
  
  - create e:EXPR with d:DTA :SELF <-
  // Create with back-link.
  ( + result:SELF;
    
    result := clone;
    result.make e with d;
    result
  );
      
  - make e:EXPR with d:DTA <-
  (
    expr     := e;
    data     := d;
    late_binding_counter := late_binding_counter + 1;
  );
    
Section Public
  
  - my_copy:SELF <-
  ( + result:SELF;
    
    result := SELF.create (expr.my_copy) with data;    
    node_list.add_last result; 
    result
  );
    
  //
  // Update.
  //
  
  - update:BOOLEAN <-
  (
    update_case & update_depth TRUE    
  );
  
Section NODE, DTA
  
  - update_link:BOOLEAN <-
  (     
    update_case & update_depth FALSE    
  );
  
Section Public
/*  
  - count_flat:INTEGER;
  - count_not_flat:INTEGER;
  
  - reset_count_flat <-
  (
    count_not_flat := 0;
    count_flat := 0;
  );
*/
Section Private  
    
  - update_case:BOOLEAN <-
  ( + typ_f:TYPE_FULL;
    + typ:TYPE;
    + lst_typ:TYPES_TMP;
    + list:FAST_ARRAY[CASE];
    + case:CASE;
    + result:BOOLEAN;
    + tb:PROFIL_BLOCK;
            
    typ_f := expr.static_type;
    tb ?= typ_f.raw;
    (
      (typ_f.is_expanded && {typ_f.raw != type_boolean}) || 
      {tb != NULL}
    ).if {
      (first_code = NULL).if {
	first_type := typ_f.raw;
	first_code := data.product first_type with expr;
      };
      result := TRUE;
    }.elseif {(typ_f.raw = type_boolean) && {count = 2}} then {
      result := TRUE;
    } else {	
      ((typ_f.raw = type_block) || {typ_f.raw.subtype_list.count != count}).if {
	lst_typ := TYPES_TMP.new;      
	expr.get_type lst_typ;      
	(! lst_typ.is_empty).if {
	  (lst_typ.count = 1).if {
	    (first_code = NULL).if {
	      first_type := lst_typ.first;
	      first_code := data.product first_type with expr;
	    };
	  } else {
	    (switch = NULL).if {
	      switch := SWITCH.create Self with expr size (lst_typ.count);
	    };
	    list := switch.list;
	    (list.count != lst_typ.count).if {
	      (lst_typ.lower).to (lst_typ.upper) do { j:INTEGER;	    
		typ := lst_typ.item j;	    
		((j > list.upper) || {typ != list.item j.id}).if {
		  case := CASE.create typ with (data.product typ with expr);		
		  list.add case to j;
		};	    
	      };	  	  	  
	    };
	  };
	};
	lst_typ.free;
      } else {
	//count_flat := count_flat + 1;
	//"Yes\n".print;
      };
    };    
    result
  );
  
  - update_depth is_first:BOOLEAN :BOOLEAN <-
  ( + result:BOOLEAN;
    + list:FAST_ARRAY[CASE];
    + typ:TYPE_FULL;
    
    (switch = NULL).if {
      (first_code != NULL).if {
	(is_first).if {
	  typ := expr.static_type;
	  (! typ.is_expanded).if {
	    typ := first_type.default.to_strict;
	  };
	  ITM_TYPE_SELF.set_run typ;
	};
	result := data.update_branch first_code;
      };
    } else {
      list := switch.list;
      (list.lower).to (list.upper) do { j:INTEGER;
	(is_first).if {
	  ITM_TYPE_SELF.set_run (list.item j.id.default.to_strict);
	};
	data.update_branch (list.item j.code);
      };
    };
    result
  );