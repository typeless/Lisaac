///////////////////////////////////////////////////////////////////////////////
//                             Lisaac Compiler                               //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name        := SLOT;

  - copyright   := "2003-2007 Benoit Sonntag";

  
  - author      := "Sonntag Benoit (bsonntag@loria.fr)";
  - comment     := "Parent for slot runnable";
  
Section Inherit
  
  - parent_itm_object:ITM_OBJECT := ITM_OBJECT;
  
Section Public
  
  - common_slot:SLOT <- Self;
  
  + base_slot:ITM_SLOT;

  - name:STRING_CONSTANT          <- base_slot.name;  
  - id_section:SECTION_           <- base_slot.id_section;    
  - priority_and_level:INTEGER    <- base_slot.priority_and_level;  
  - priority:INTEGER              <- base_slot.priority;
  - associativity:STRING_CONSTANT <- base_slot.associativity;  
  - style:CHARACTER               <- base_slot.style;
  
  + receiver_type:TYPE;
        
  + slot_id:SLOT_DATA;
  
  + arguments:FAST_ARRAY[ARGUMENT];
  + results_type:FAST_ARRAY[TYPE_FULL];
  + result_type:TYPE_FULL;
  
  //
  // Result / Argument manager.
  //
    
  - get_expr_result:EXPR <-
  ( + result:EXPR;
    + lst:FAST_ARRAY[EXPR];
    + typ:TYPE_FULL;
    
    (id_section.is_interrupt).if {
      typ := type_pointer.default;
      result := typ.get_temporary_expr position;
    } else {
      (results_type != NULL).if { 
	lst := FAST_ARRAY[EXPR].create_with_capacity (results_type.count+1);
	(results_type.lower).to (results_type.upper) do { k:INTEGER;	  
	  lst.add_last (results_type.item k.get_temporary_expr position);
	};
	lst.add_last (result_type.get_temporary_expr position);
	result := EXPR_MULTIPLE.create lst;
      } else {	
	result := result_type.get_temporary_expr position;
      };      
    };
    result
  );
      
  - check_argument_type_for larg:FAST_ARRAY[EXPR] <-  
  ( + new_expr:EXPR;
          
    (larg.lower + 1).to (larg.upper) do { i:INTEGER;      
      new_expr := larg.item i.check_type (arguments.item i.type) with position;
      larg.put new_expr to i;
    };            
  );
      
  //
  // Creation.
  //
  
  - create s:ITM_SLOT type t:TYPE :SLOT <-
  ( + result:SLOT;
    
    result := clone;
    result.make s type t    
  );
  
  - make s:ITM_SLOT type t:TYPE :SLOT <-
  ( + styl:SLOT;
    + item_lst:FAST_ARRAY[ITM_ARGUMENT];  
    + typ:TYPE_FULL;
    + type_multiple:ITM_TYPE_MULTI;
    + type_mono:ITM_TYPE_MONO;
    
    base_slot := s;
    receiver_type := t;
    position  := s.position;
    CONTEXT_TMP.push_generic t;
    //
    (s.affect = '<').if {
      // Code.      
      styl := slot_code_intern := SLOT_CODE.create Self with (base_slot.value);      
    } else {
      // Data      
      create_slot_data;
      styl := slot_data_intern;
    };    
    // Arguments.
    item_lst  := base_slot.argument_list; 
    arguments := FAST_ARRAY[ARGUMENT].create_with_capacity (base_slot.argument_count);    
    (item_lst.lower).to (item_lst.upper) do { j:INTEGER;
      item_lst.item j.to_run arguments;
    };    
    // Result(s).    
    type_multiple ?= base_slot.type;
    (type_multiple != NULL).if {  
      results_type := FAST_ARRAY[TYPE_FULL].create_with_capacity (type_multiple.count - 1);	
      0.to (type_multiple.upper - 1) do { k:INTEGER;	  
	typ := type_multiple.item k.to_run;	
	results_type.add_last typ;
      };
      result_type := type_multiple.last.to_run;	
    } else {
      type_mono ?= base_slot.type;
      result_type := type_mono.to_run;
    };      
    CONTEXT.pop;
    //
    styl
  );
    
  //
  // Style.
  //
  
  - lower_style:INTEGER <-
  ( + result:INTEGER;
    (slot_data_intern = NULL).if {
      result := 1;
    };
    result
  );
  
  - upper_style:INTEGER <- 
  ( + result:INTEGER;
    (slot_code_intern != NULL).if {      
      (slot_code_list != NULL).if {
	result := slot_code_list.upper + 2;
      } else {
	result := 1;
      };
    };
    result
  );
  
  - slot_data:SLOT_DATA <-
  (     
    (slot_data_intern = NULL).if {
      create_slot_data;      
      (slot_id = NULL).if {
	slot_id := SLOT_DATA.create common_slot type (TYPE_ID.get_index 1.default);
	slot_id.init;
      };
    };
    slot_data_intern
  );
    
  - slot_code idx:INTEGER :SLOT_CODE <-
  ( + result:SLOT_CODE;
    
    (idx = 1).if {
      result := slot_code_intern;
    } else {
      result := slot_code_list.item (idx-2);
    };
    result
  );

  - add_style v:ITM_CODE :INTEGER <-
  ( + slot:SLOT_CODE;
    + result:INTEGER;
           
    slot := SLOT_CODE.create common_slot with v;
    (slot_code_intern = NULL).if {
      slot_code_intern := slot;
      slot_id := SLOT_DATA.create common_slot type (TYPE_ID.get_index 0.default);
      slot_id.init;
      result := 1;
    } else {
      (slot_code_list = NULL).if {
	slot_code_list := FAST_ARRAY[SLOT_CODE].create_with_capacity 1;
      };
      slot_code_list.add_last slot;
      (slot_id = NULL).if {
	slot_id := SLOT_DATA.create common_slot type (TYPE_ID.get_index 1.default);
	slot_id.init;
      };
      result := slot_code_list.upper + 2;
    };    
    result
  );

  //
  // Display.
  //
  
  - display_all <-
  (
    (lower_style).to (upper_style) do { j:INTEGER;
      item_style j.display_all;
    };
  );

Section Public
  
  + slot_data_intern:SLOT_DATA; // Index 0
  + slot_code_intern:SLOT_CODE; // Index 1
  
  + slot_code_list:FAST_ARRAY[SLOT_CODE]; // Index x+2
  + slot_data_list:FAST_ARRAY[SLOT_DATA]; // Vector data slot  
  
  - create_slot_data <-
  ( + typ:TYPE_FULL;
                
    (results_type != NULL).if {            
      slot_data_list := FAST_ARRAY[SLOT_DATA].create_with_capacity (results_type.count);
      (results_type.lower).to (results_type.upper) do { k:INTEGER;	
	typ := results_type.item k;
	slot_data_list.add_last (
	  SLOT_DATA.create common_slot type typ
	);
      };      
    };
    slot_data_intern := SLOT_DATA.create common_slot type result_type;    
  );