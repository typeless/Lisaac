///////////////////////////////////////////////////////////////////////////////
//                             Lisaac Compiler                               //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name        := PROTOTYPE;

  - copyright   := "2003-2007 Benoit Sonntag";

  
  - author      := "Sonntag Benoit (bsonntag@loria.fr)";
  - comment     := "Prototype source code.";
  
Section Inherit

  + parent_named:Expanded NAMED;
  
Section Public
  
  - prototype_list:FAST_ARRAY[PROTOTYPE] :=
  FAST_ARRAY[PROTOTYPE].create_with_capacity 512;
  // BSBS: Voir si il faut le conserver !
  
  - prototype_dico:HASHED_DICTIONARY[PROTOTYPE,STRING_CONSTANT] := 
  HASHED_DICTIONARY[PROTOTYPE,STRING_CONSTANT].create;
  
Section Public
  
  + index:INTEGER; // in `prototype_list', for POSITION.
  
  + shortname:STRING_CONSTANT;
  
  //
  // Slots
  //
  
  + slot_list:HASHED_DICTIONARY[ITM_SLOT,STRING_CONSTANT];
  
  + first_slot:ITM_SLOT;
  
  + last_slot:ITM_SLOT;
  
  - add_slot s:ITM_SLOT <-
  (     
    slot_list.fast_put s to (s.name);
    (first_slot = NULL).if {
      first_slot := s;
    } else {
      last_slot.set_next s;
    };
    last_slot := s;
  );    
  
  - search_parent n:STRING_CONSTANT :BOOLEAN <-
  ( + slot:ITM_SLOT;
    + result:BOOLEAN;
    
    slot := first_slot;
    {
      (result := (slot != NULL) && {slot.id_section.is_inherit_or_insert}) 
      && {slot.name != n}
    }.while_do {
      slot := slot.next;
    };
    result
  );
      
  //
  // Run Slot.
  //
  
  - init_slot_for typ:TYPE <-
  ( + cur:ITM_SLOT;
            
    // Parent.
    cur := first_slot;
    {(cur != NULL) && {cur.id_section.is_inherit_or_insert}}.while_do {      
      typ.slot_run.add_last (SLOT.create cur type typ);
      cur := cur.next;
    };
    // Mapping.
    (is_mapping).if {
      {cur != NULL}.while_do {
	(cur.id_section.is_mapping).if {
	  ? {cur.style = '+'};
	  typ.slot_run.add_last (SLOT.create cur type typ);
	};
	cur := cur.next;
      };
    };	  
  );
	  
  //
  // Mapping / Late binding / Expanded
  //
  
  + type_style:STRING_CONSTANT; // Reference / Expanded / Strict.
  
  + is_mapping:BOOLEAN;

  - set_mapping <-
  (
    is_mapping := TRUE;
  );
  
  - set_type_style s:STRING_CONSTANT <- 
  ( 
    type_style := s;
  );
  
  //
  // Cast information.
  //

  + export_list:FAST_ARRAY[ITM_TYPE_MONO];
  + import_list:FAST_ARRAY[ITM_TYPE_MONO];

  - set_export_list s:FAST_ARRAY[ITM_TYPE_MONO] <-
  (
    export_list := s;
  );

  - set_import_list s:FAST_ARRAY[ITM_TYPE_MONO] <-
  (
    import_list := s;
  );

  //
  // Source file.
  //

  + filename:STRING_CONSTANT;   // Pathname of prototype.

  + source  : STRING;   // Text source code.
  
  + generic_count:INTEGER;
  
  + idf_generic_list:FAST_ARRAY[ITM_TYPE_PARAMETER];
  
  //
  // Default value.
  //

  + default_value:ITM_CODE;

  - set_default_value v:ITM_CODE <-
  ( 
    default_value := v; //default_value v to_slot name in Self;
  );
  
  //
  // Creation.
  //
  
  - create f:STRING_CONSTANT name n:STRING_CONSTANT generic_count c:INTEGER :SELF <-
  ( + result:SELF;
    result := clone;
    result.make f name n generic_count c;
    result
  );
  
  - make f:STRING_CONSTANT name n:STRING_CONSTANT generic_count c:INTEGER <-
  ( //+ file:STD_FILE;
    //+ entry:ENTRY;
    + file:POINTER;
    + sz,idx:INTEGER;
    ? {! prototype_dico.fast_has n};
    ? {n != NULL};
    
    filename := f;
    name     := n;    
    idx := n.fast_last_index_of '.';
    (idx != 0).if {
      string_tmp.copy n;
      string_tmp.remove_first idx;
      shortname := ALIAS_STR.get string_tmp;
    } else {
      shortname := n;
    };
    generic_count := c;
    idf_generic_list := FAST_ARRAY[ITM_TYPE_PARAMETER].create_with_capacity c;
        
    // Collection.    
    index := prototype_list.count;
    prototype_list.add_last Self;
    prototype_dico.fast_put Self to f; 
    
    // Read file.            
    //entry := FILE_SYSTEM.get f;        
    //file ?= entry.open_read_only;
    //source := STRING.create (file.size);
    //file.read source size (file.size);
    //file.close;
    
    file := FS_MIN.open_read f;
    sz := FS_MIN.file_size file;
    source := STRING.create (sz+1);
    FS_MIN.read file in source size sz;
    FS_MIN.close file;
    
    // Init.    
    slot_list := HASHED_DICTIONARY[ITM_SLOT,STRING_CONSTANT].create;        
    position  := POSITION.create Self line 1 column 0;
    //
  );

  //
  // Execute.
  //
            
  - depend <-
  ( + slot_main:SLOT;
    + self_main:EXPR;
    + base:NODE;
    + pass_count_depend:INTEGER;
    + i:INSTR;
    + cmd:STRING_CONSTANT;
    
    + buf:STRING;

    //
    // Creation list execution.
    //    
    list_current := LIST.create position;
    (debug_level_option != 0).if {
      // Debug mode : Add context local.
      context_main := TYPE_CONTEXT.default.new_local position 
      name (ALIAS_STR.variable_context) style '+';
      context_main.set_ensure_count 1;      
      list_current.add_last (PUSH.create position context context_main first TRUE);
    };
        
    // Command argument.
    (is_ansi).if {      
      (is_java).if {
        cmd := "arg = parg";
      } else {
        string_tmp.clear;
        (debug_level_option != 0).if {
          string_tmp.copy "signal(SIGINT,interrupt_signal);\n  ";
        };
        string_tmp.append
        "arg_count  = argc;\n\
        \  arg_vector = argv;\n\
        \#ifdef _PTHREAD_H\n\
        \  pthread_key_create(&current_thread, NULL);\n\
        \  pthread_attr_init(&thread_attr);\n\
        \  /*pthread_attr_setdetachstate(&thread_attr,PTHREAD_CREATE_DETACHED);*/\n\
        \#endif\n  ";        
        cmd := ALIAS_STR.get string_tmp;
      };
      i := EXTERNAL_C.create position text cmd
      access NULL persistant TRUE type (TYPE_VOID.default);
      list_current.add_last i;
    };
    // Main Call.
    slot_main := get_slot_main;
    self_main := PROTOTYPE_CST.create position type (type_input.default);
    base := NODE.new_read (slot_main.position) slot slot_main 
    receiver self_main self self_main intern TRUE;    
    list_current.add_last base;
        
    // Result.    
    list_current.add_last (INTEGER_CST.create position value 0 type (type_integer.default)); 
    list_main := list_current;
            
    //
    // Detect life code.
    //    
    pass_count := 1;
    (is_quiet).if_false {
      STD_ERROR.put_string "Depending pass: .";   
    };
    {modify_count != 0}.while_do {
      modify_count := 0;
      (is_quiet).if_false {
	STD_ERROR.put_string ".";
      };
      pass_count := pass_count + 1;
      NODE.extend_pass;
    };
    
    (is_quiet).if_false {
      STD_ERROR.put_string " (";
      STD_ERROR.put_integer pass_count;
      STD_ERROR.put_string ")\n";
    };
    
    buf := STRING.create 2000;
            
    (is_verbose).if {
      PROFIL_LIST.display;
    };
    
    //
    // Evaluation.
    //
    (is_quiet).if_false {
      STD_ERROR.put_string "Executing pass: ";
    };
    pass_count_depend := pass_count;
    
    // First pass (recursive)    
    is_executing_pass := TRUE;            
    (is_quiet).if_false {
      STD_ERROR.put_string "*";
    };
    pass_count := pass_count + 1;
    PROFIL_LIST.execute_pass_recursive;
    // End first pass.    
    {
      modify_count := 0;
      null_counter := 0;
      (is_quiet).if_false {
	STD_ERROR.put_string ".";            
      };
      pass_count := pass_count + 1;            
      
      SWITCH.reset_switch_new_pass;
      
      PROFIL_LIST.execute_pass;      
      
      (SWITCH.switch_new_pass).if {
	new_execute_pass;	
      };
      
    }.do_while 
    //{pass_count < 40};
    {modify_count != 0};
    
    (is_quiet).if_false {
      STD_ERROR.put_string " (";
      STD_ERROR.put_integer (pass_count - pass_count_depend);
      STD_ERROR.put_string ")\n";          
    };
    //    
    (is_verbose).if {
      list_main.debug_display;
      PROFIL_LIST.display;
    };            
  );
    
  //
  // Type C
  //
    
  + type_c     :STRING_CONSTANT;

  - set_c_type n:STRING_CONSTANT <-
  (
    type_c := n;    
  );
  
  //
  // Shorter.
  //
  
  - shorter_out buf:STRING <-
  ( 
    put name to buf like (ALIAS_STR.short_title);
    
    list_tmp.clear;
    shorter_get_all_slot_in list_tmp;
    
    // Table.
    shorter_table list_tmp select { sl:ITM_SLOT; 
      sl.id_section.is_inherit_or_insert
    } title "Inherit Summary" in buf;
    
    shorter_table list_tmp select { sl:ITM_SLOT; 
      sl.name.has_prefix "create"
    } title "Constructor Summary" in buf;    
    
    shorter_table list_tmp select { sl:ITM_SLOT; 
      (! sl.name.has_prefix "create") && {!sl.id_section.is_inherit_or_insert}
    } title "Slot Summary" in buf;    
        
    // Detail.
    shorter_detail list_tmp select { sl:ITM_SLOT; 
      sl.id_section.is_inherit_or_insert
    } title "Inherit Detail" in buf;    
    
    shorter_detail list_tmp select { sl:ITM_SLOT; 
      sl.name.has_prefix "create"
    } title "Constructor Detail" in buf;    
    
    shorter_detail list_tmp select { sl:ITM_SLOT; 
      (! sl.name.has_prefix "create") && {!sl.id_section.is_inherit_or_insert}
    } title "Slot Detail" in buf;    
        
  );
  
Section PROTOTYPE
  
  - get_slot_main:SLOT <-
  ( + result:SLOT;    
    + s:ITM_SLOT;    
            
    s := first_slot;    
    {  
      ((s.id_section.is_public) && {s.name = ALIAS_STR.slot_main}).if {	
	(s.result_type != ITM_TYPE_SIMPLE.type_void).if {
	  semantic_error ((s.position),"Unix mode: Not value return.");
	};
	(s.argument_count != 1).if {
	  semantic_error ((s.position),"Unix mode: Not argument list.");
	};	
	result := type_input.get_slot (s.name);
      };
      s := s.next;
    }.do_while {(s != NULL) && {result = NULL}};
    
    (result = NULL).if {
      semantic_error (position,"Entry point not found (slot `main' in `Section Public').");
    };        
    result     
  );
  
  - shorter_get_all_slot_in lst:FAST_ARRAY[ITM_SLOT] <-
  ( + s:ITM_SLOT; 
    + ps:ITM_TYPE_SIMPLE;
    + p:PROTOTYPE;
    + i:INTEGER;
    
    s := first_slot;
    {s != NULL}.while_do {
      i := lst.lower;
      {(i <= lst.upper) && {lst.item i.name != s.name}}.while_do {
        i := i + 1;
      };
      (i > lst.upper).if {
        lst.add_last s;
      };
      s := s.next;
    };
    
    // Parent.
    s := first_slot;
    {(s != NULL) && {s.id_section.is_inherit_or_insert}}.while_do {      
      ps ?= s.result_type;
      ((ps != NULL) && {s.style = '+'} && {ps.style = ALIAS_STR.keyword_expanded}).if {
        p := NULL;
        i := prototype_list.lower;
        {(i <= prototype_list.upper) && {p = NULL}}.while_do {                              
          (prototype_list.item i.name = ps.name).if {
            p := prototype_list.item i;
          };
          i := i + 1;
        };
        (p != NULL).if {            
          p.shorter_get_all_slot_in lst;
        };
      };      
      s := s.next;
    };    
  );
        
  - shorter_table lst:FAST_ARRAY[ITM_SLOT] select sel:BLOCK 
  title t:STRING_CONSTANT in buf:STRING <-
  ( + is_first_cur:BOOLEAN;
    + s:ITM_SLOT; 
    
    is_first_cur := TRUE;    
    (lst.lower).to (lst.upper) do { i:INTEGER;
      s := lst.item i;
      (sel.value s).if {
        (is_first_cur).if {
          put t to buf like (ALIAS_STR.short_table_begin);
          is_first_cur := FALSE;
        };
        string_tmp.clear;
        string_tmp2.clear;
        s.pretty_name_in string_tmp2;
        put string_tmp2 to string_tmp like (ALIAS_STR.short_table_slot_name);
        (
          (s.id_section.is_inherit_or_insert) && 
          {(s.style != '+') || {
              + ts:ITM_TYPE_SIMPLE;
              ts ?= s.result_type;
              (ts = NULL) || {ts.style != ALIAS_STR.keyword_expanded}
          }}
        ).if {
          put " No developed." to string_tmp like (ALIAS_STR.short_warning);
        };
        string_tmp2.clear;        
        get_all_comment_slot (s.name) in string_tmp2;
        put string_tmp2 to string_tmp like (ALIAS_STR.short_table_slot_comment);
        put string_tmp to buf like (ALIAS_STR.short_table_item);
      };     
    };    
    (is_first_cur).if_false {
      put NULL to buf like (ALIAS_STR.short_table_end);
    };    
  );
  
  - shorter_detail lst:FAST_ARRAY[ITM_SLOT] select sel:BLOCK 
  title t:STRING_CONSTANT in buf:STRING <-
  ( + is_first:BOOLEAN;
    + s:ITM_SLOT;
      
    is_first := TRUE;
    (lst.lower).to (lst.upper) do { i:INTEGER;
      s := lst.item i;
      (sel.value s).if {
        (is_first).if {
          put t to buf like (ALIAS_STR.short_sub_title);
          is_first := FALSE;
        };
        string_tmp2.clear;
        s.pretty_name_in string_tmp2;
        put string_tmp2 to buf like (ALIAS_STR.short_slot_title);
        string_tmp.copy (s.position.prototype.filename);
        string_tmp.append " line #";
        s.position.line.append_in string_tmp;
        put string_tmp to buf like (ALIAS_STR.short_prototype_path);
        put "Profile:" to buf like (ALIAS_STR.short_subsub_title);
        s.shorter_profile_in buf;
        put "Description:" to buf like (ALIAS_STR.short_subsub_title);
        string_tmp.clear;
        get_all_comment_slot (s.name) in string_tmp;
        put string_tmp to buf like (ALIAS_STR.short_comment_slot_line);
        put "Parameters:" to buf like (ALIAS_STR.short_subsub_title);
        put "Contracts:" to buf like (ALIAS_STR.short_subsub_title);
        put "See also:" to buf like (ALIAS_STR.short_subsub_title);        
      };      
    };
  );
  
  - get_all_comment_slot n:STRING_CONSTANT in buf:STRING <-
  ( + s:ITM_SLOT; 
    + ps:ITM_TYPE_SIMPLE;
    + p:PROTOTYPE;
    + i:INTEGER;
        
    s := slot_list.fast_reference_at n;
    ((s != NULL) && {s.comment != NULL}).if {
      buf.append (s.comment);
    };
    // Parent.
    s := first_slot;
    {(s != NULL) && {s.id_section.is_inherit_or_insert}}.while_do {      
      ps ?= s.result_type;
      (ps != NULL).if {                
        p := NULL;
        i := prototype_list.lower;
        {(i <= prototype_list.upper) && {p = NULL}}.while_do {                              
          (prototype_list.item i.name = ps.name).if {
            p := prototype_list.item i;
          };
          i := i + 1;
        };
        (p != NULL).if {            
          p.get_all_comment_slot n in buf;
        };
      };      
      s := s.next;
    };
  );
  
  - list_tmp:FAST_ARRAY[ITM_SLOT] := FAST_ARRAY[ITM_SLOT].create_with_capacity 256;