///////////////////////////////////////////////////////////////////////////////
//                             Lisaac Library                                //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////

Section Header

  + name := BOOLEAN_TEST;

  - copyright := "2009 Jeremy Cowgar";

  - comment := "Test suite for BOOLEAN.";

Section Public

  - did_pass (name:ABSTRACT_STRING, v:BOOLEAN) <-
  (
    v.if {
      UNIT_TEST.test_passed name;
    } else {
      UNIT_TEST.test_failed name;
    };
  );

  - run <-
  ( + pass:BOOLEAN;
    + tmp:STRING;

    UNIT_TEST.suite "BOOLEAN";

    UNIT_TEST.section "Conditional";

    pass := FALSE;
    TRUE.if_true { pass := TRUE; };
    did_pass ("TRUE.if_true", pass);

    pass := TRUE;
    FALSE.if_true { pass := FALSE; };
    did_pass ("FALSE.if_true", pass);

    pass := FALSE;
    FALSE.if_false { pass := TRUE; };
    did_pass ("FALSE.if_false", pass);

    pass := TRUE;
    TRUE.if_false { pass := FALSE; };
    did_pass ("TRUE.if_false", pass);

    TRUE.if { pass := TRUE; } else { pass := FALSE; };
    did_pass ("TRUE.if", pass);

    FALSE.if { pass := FALSE; } else { pass := TRUE; };
    did_pass ("FALSE.if", pass);

    TRUE.if_true { pass := TRUE; } else { pass := FALSE; };
    did_pass ("TRUE.if_true else", pass);

    FALSE.if_true { pass := FALSE; } else { pass := TRUE; };
    did_pass ("FALSE.if_true else", pass);

    TRUE.if_false { pass := FALSE; } else { pass := TRUE; };
    did_pass ("TRUE.if_false else", pass);

    FALSE.if_false { pass := TRUE; } else { pass := FALSE; };
    did_pass ("FALSE.if_false else", pass);

    pass := FALSE;
    TRUE.if { pass := TRUE; };
    did_pass ("TRUE.if", pass);

    pass := TRUE;
    FALSE.if { pass := FALSE; };
    did_pass ("FALSE.if", pass);

    TRUE.if { 
      pass := TRUE;
    }.elseif { FALSE } then {
      pass := FALSE;
    };
    did_pass ("TRUE.if elseif", pass);

    FALSE.if {
      pass := FALSE;
    }.elseif { TRUE } then {
      pass := TRUE;
    };
    did_pass ("FALSE.if elseif", pass);

    FALSE.if {
      pass := FALSE;
    }.elseif { FALSE } then {
      pass := FALSE;
    }.elseif { TRUE } then {
      pass := TRUE;
    };
    did_pass ("FALSE.if elseif elseif", pass);

    FALSE.if {
      pass := FALSE;
    }.elseif { TRUE } then {
      pass := TRUE;
    } else {
      pass := FALSE;
    };
    did_pass ("FALSE.if elseif else #1", pass);

    FALSE.if {
      pass := FALSE;
    }.elseif { FALSE } then {
      pass := FALSE;
    } else {
      pass := TRUE;
    };
    did_pass ("FALSE.if elseif else #2", pass);

    /*
    // else_if alias repeat of the above
    // TODO: I get a runtime error "Slot deferred" on all of these.
    FALSE.if {
      pass := FALSE;
    }.else_if { TRUE } then {
      pass := TRUE;
    };
    did_pass ("FALSE.if else_if", pass);

    FALSE.if {
      pass := FALSE;
    }.else_if { FALSE } then {
      pass := FALSE;
    }.else_if { TRUE } then {
      pass := TRUE;
    };
    did_pass ("FALSE.if else_if else_if", pass);

    FALSE.if {
      pass := FALSE;
    }.else_if { TRUE } then {
      pass := TRUE;
    } else {
      pass := FALSE;
    };
    did_pass ("FALSE.if else_if else #1", pass);

    FALSE.if {
      pass := FALSE;
    }.else_if { FALSE } then {
      pass := FALSE;
    } else {
      pass := TRUE;
    };
    did_pass ("FALSE.if else_if else #2", pass);
    */

    UNIT_TEST.section "Binary operator";
    UNIT_TEST.test "|| #1" boolean ({TRUE} || {FALSE}) equals TRUE;
    UNIT_TEST.test "|| #2" boolean ({FALSE} || {TRUE}) equals TRUE;
    UNIT_TEST.test "|| #3" boolean ({TRUE} || {TRUE}) equals TRUE;
    UNIT_TEST.test "|| #4" boolean ({FALSE} || {FALSE}) equals FALSE;
    UNIT_TEST.test "&& #1" boolean ({TRUE} && {TRUE}) equals TRUE;
    UNIT_TEST.test "&& #2" boolean ({TRUE} && {FALSE}) equals FALSE;
    UNIT_TEST.test "&& #3" boolean ({FALSE} && {TRUE}) equals FALSE;
    UNIT_TEST.test "&& #4" boolean ({FALSE} && {FALSE}) equals FALSE;
    UNIT_TEST.test "| #1" boolean (TRUE | FALSE) equals TRUE;
    UNIT_TEST.test "| #2" boolean (FALSE | TRUE) equals TRUE;
    UNIT_TEST.test "| #3" boolean (TRUE | TRUE) equals TRUE;
    UNIT_TEST.test "| #4" boolean (FALSE | FALSE) equals FALSE;
    UNIT_TEST.test "& #1" boolean (TRUE & TRUE) equals TRUE;
    UNIT_TEST.test "& #2" boolean (TRUE & FALSE) equals FALSE;
    UNIT_TEST.test "& #3" boolean (FALSE & TRUE) equals FALSE;
    UNIT_TEST.test "& #4" boolean (FALSE & FALSE) equals FALSE;
    UNIT_TEST.test "^ #1" boolean (TRUE ^ TRUE) equals FALSE;
    UNIT_TEST.test "^ #2" boolean (TRUE ^ FALSE) equals TRUE;
    UNIT_TEST.test "^ #3" boolean (FALSE ^ TRUE) equals TRUE;
    UNIT_TEST.test "^ #4" boolean (FALSE ^ FALSE) equals FALSE;
    UNIT_TEST.test "-> #1" boolean (TRUE -> TRUE) equals TRUE;
    UNIT_TEST.test "-> #2" boolean (TRUE -> FALSE) equals FALSE;
    UNIT_TEST.test "-> #3" boolean (FALSE -> TRUE) equals TRUE;
    UNIT_TEST.test "-> #4" boolean (FALSE -> FALSE) equals TRUE;
    UNIT_TEST.test "->> #1" boolean (TRUE ->> { TRUE }) equals TRUE;
    UNIT_TEST.test "->> #2" boolean (TRUE ->> { FALSE }) equals FALSE;
    UNIT_TEST.test "->> #3" boolean (FALSE ->> { TRUE }) equals TRUE;
    UNIT_TEST.test "->> #4" boolean (FALSE ->> { FALSE }) equals TRUE;

    UNIT_TEST.test "! #1" boolean (! TRUE) equals FALSE;
    UNIT_TEST.test "! #2" boolean (! FALSE) equals TRUE;
    UNIT_TEST.test "! #3" boolean (! (FALSE | FALSE)) equals TRUE;
    UNIT_TEST.test "! #4" boolean (! (TRUE | FALSE)) equals FALSE;
    UNIT_TEST.test "! #5" boolean (! (TRUE & TRUE)) equals FALSE;
    UNIT_TEST.test "! #6" boolean (! (FALSE & TRUE)) equals TRUE;

    UNIT_TEST.section "Conversion";
    UNIT_TEST.test "to_string #1" string (TRUE.to_string) equals "1";
    UNIT_TEST.test "to_string #2" string (FALSE.to_string) equals "0";
    UNIT_TEST.test "to_integer #1" integer (TRUE.to_integer) equals 1;
    UNIT_TEST.test "to_integer #2" integer (FALSE.to_integer) equals 0;
    UNIT_TEST.test "to_character #1" character (TRUE.to_character) equals '1';
    UNIT_TEST.test "to_character #2" character (FALSE.to_character) equals '0';

    tmp := STRING.create 5;
    TRUE.append_in tmp;
    UNIT_TEST.test "TRUE.append_in" string tmp equals "1";

    FALSE.append_in tmp;
    UNIT_TEST.test "FALSE.append_in" string tmp equals "10";
  );
