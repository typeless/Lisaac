// C code generated by Lisaac compiler (www.isaacOS.com) //
int arg_count;
char **arg_vector;

//==========================//
// EXTERNAL                 //
//==========================//

// INSTALL_LISAAC
#include <unistd.h>
// MEMORY

#define MINIMUM_SIZE 256  
void *table_size[MINIMUM_SIZE/sizeof(void *)];
void *last_block[64];

// SYSTEM_IO

#include <stdio.h>
#include <stdlib.h>
  
// Hardware 'print_char'
void print_char(char car)
{
  fputc(car,stdout);
}

// Hardware 'exit'
int die_with_code(int code)
{
  exit(code);
}


// SYSTEM
#include <time.h>

//==========================//
// TYPE                     //
//==========================//

// Generic Object
struct ___OBJ {
  unsigned long __id;
};

// NULL
#ifndef NULL
#define NULL ((void *)0)
#endif

// INTEGER
typedef int __INTEGER;

// CHARACTER
typedef char __CHARACTER;

// STRING
#define __STRING__ 4
typedef struct STRING_struct __STRING;
struct STRING_struct {
  unsigned long __id;
  __INTEGER count__CB;
  __INTEGER capacity__CJD;
  __CHARACTER *storage__5JD;
};
__STRING STRING_={__STRING__};
#define STRING__ (&STRING_)

// STRING_CONSTANT
#define __STRING_CONSTANT__ 5
typedef struct STRING_CONSTANT_struct __STRING_CONSTANT;
struct STRING_CONSTANT_struct {
  unsigned long __id;
  __INTEGER count__AD;
  __CHARACTER *storage__KEC;
};
__STRING_CONSTANT STRING_CONSTANT_={__STRING_CONSTANT__};
#define STRING_CONSTANT__ (&STRING_CONSTANT_)

// POINTER
typedef void * __POINTER;

// UINTEGER_32
typedef unsigned long __UINTEGER_32;

// MEMORY
#define __MEMORY__ 0
typedef struct MEMORY_struct __MEMORY;
struct MEMORY_struct {
  __UINTEGER_32 previous_linear__3W;
  __UINTEGER_32 size_and_id__4W;
  void *next_free__5W;
  void *previous_free__AX;
} __attribute__ ((packed));
__MEMORY MEMORY_;
#define MEMORY__ (&MEMORY_)

// NUMERIC
#define __NUMERIC__ 1
typedef struct {} __NUMERIC;
#define NUMERIC_ 1
#define NUMERIC__ ((void *)1)

// OBJECT
#define __OBJECT__ 2
typedef struct {} __OBJECT;
#define OBJECT_ 1
#define OBJECT__ ((void *)1)

// INSTALL_LISAAC
#define __INSTALL_LISAAC__ 3
typedef struct {} __INSTALL_LISAAC;
#define INSTALL_LISAAC_ 1
#define INSTALL_LISAAC__ ((void *)1)

// TRUE
#define TRUE__ 1

// FALSE
#define FALSE__ 0

// BOOLEAN
typedef char __BOOLEAN;

// INTEGER_8
typedef signed char __INTEGER_8;


void *table_type[4];

//==========================//
// GLOBAL                   //
//==========================//

void *parent_numeric__G;
__POINTER begin_memory__YJC;
__UINTEGER_32 nb_page__5XC;
__UINTEGER_32 capacity_max__ZKF;
void *first_free__XTI;
__UINTEGER_32 clone_allocation_size__TW;
void *string_tmp__2;
void *path_current__GB;
void *path_home__KB;
void *shell__MB;
__INTEGER step_count__0C;
void *system__FE;

//==========================//
// STRING CONSTANT          //
//==========================//

__STRING_CONSTANT __string_1={__STRING_CONSTANT__,106,"\t\t=================\
===============\n\t\t= Auto-Install Lisaac Compiler =\n\t\t=================\
===============\n\n"};
__STRING_CONSTANT __string_2={__STRING_CONSTANT__,4,"HOME"};
__STRING_CONSTANT __string_3={__STRING_CONSTANT__,5,"SHELL"};
__STRING_CONSTANT __string_4={__STRING_CONSTANT__,17,"Detection system."};
__STRING_CONSTANT __string_5={__STRING_CONSTANT__,48,"  Error : SHELL enviro\
nment variable is empty !\n"};
__STRING_CONSTANT __string_6={__STRING_CONSTANT__,7,"Unknown"};
__STRING_CONSTANT __string_7={__STRING_CONSTANT__,4,"bash"};
__STRING_CONSTANT __string_8={__STRING_CONSTANT__,8,"/.bashrc"};
__STRING_CONSTANT __string_9={__STRING_CONSTANT__,11,"Unix - bash"};
__STRING_CONSTANT __string_10={__STRING_CONSTANT__,29,"\n# **** LISAAC COMPI\
LER ****\n"};
__STRING_CONSTANT __string_11={__STRING_CONSTANT__,12,"export PATH="};
__STRING_CONSTANT __string_12={__STRING_CONSTANT__,12,"/bin:$PATH\n\n"};
__STRING_CONSTANT __string_13={__STRING_CONSTANT__,4,"tcsh"};
__STRING_CONSTANT __string_14={__STRING_CONSTANT__,7,"/.cshrc"};
__STRING_CONSTANT __string_15={__STRING_CONSTANT__,11,"Unix - tcsh"};
__STRING_CONSTANT __string_16={__STRING_CONSTANT__,10,"set path=("};
__STRING_CONSTANT __string_17={__STRING_CONSTANT__,13,"/bin $path)\n\n"};
__STRING_CONSTANT __string_18={__STRING_CONSTANT__,3,"zsh"};
__STRING_CONSTANT __string_19={__STRING_CONSTANT__,8,"/.zshenv"};
__STRING_CONSTANT __string_20={__STRING_CONSTANT__,10,"Unix - zsh"};
__STRING_CONSTANT __string_21={__STRING_CONSTANT__,24,"  Shell not recognize\
d: "};
__STRING_CONSTANT __string_22={__STRING_CONSTANT__,15,"C:\\autoexec.bat"};
__STRING_CONSTANT __string_23={__STRING_CONSTANT__,13,"Windows - DOS"};
__STRING_CONSTANT __string_24={__STRING_CONSTANT__,33,"\r\nREM **** LISAAC C\
OMPILER ****\r\n"};
__STRING_CONSTANT __string_25={__STRING_CONSTANT__,9,"set path="};
__STRING_CONSTANT __string_26={__STRING_CONSTANT__,15,"\\bin;%path%\r\n\r\n"};
__STRING_CONSTANT __string_27={__STRING_CONSTANT__,17,"  System detect: "};
__STRING_CONSTANT __string_28={__STRING_CONSTANT__,7,"path.li"};
__STRING_CONSTANT __string_29={__STRING_CONSTANT__,10,"  + target"};
__STRING_CONSTANT __string_30={__STRING_CONSTANT__,23,"  + target := WINDOWS\
;\n"};
__STRING_CONSTANT __string_31={__STRING_CONSTANT__,34,"\n  Note: Use `mingw'\
 for Windows.\n"};
__STRING_CONSTANT __string_32={__STRING_CONSTANT__,20,"  + target := UNIX;\n"};
__STRING_CONSTANT __string_33={__STRING_CONSTANT__,49,"\n  Search path for `\
libX11.a' : (please wait...)\n"};
__STRING_CONSTANT __string_34={__STRING_CONSTANT__,55,"find /usr -name \"lib\
X11.a\" 2> /dev/null > xlib_path.txt"};
__STRING_CONSTANT __string_35={__STRING_CONSTANT__,13,"xlib_path.txt"};
__STRING_CONSTANT __string_36={__STRING_CONSTANT__,33," Error : `libX11.a' n\
ot found !\n\n"};
__STRING_CONSTANT __string_37={__STRING_CONSTANT__,21,"  + path_lib_x11 := \""};
__STRING_CONSTANT __string_38={__STRING_CONSTANT__,3,"\";\n"};
__STRING_CONSTANT __string_39={__STRING_CONSTANT__,16,"  + path_lib_x11"};
__STRING_CONSTANT __string_40={__STRING_CONSTANT__,19,"rm -f xlib_path.txt"};
__STRING_CONSTANT __string_41={__STRING_CONSTANT__,38,"Installation of envir\
onment variables."};
__STRING_CONSTANT __string_42={__STRING_CONSTANT__,98,"  Auto-install fail !\
\n  You have to change your environment variables as following: \n    set pa\
th="};
__STRING_CONSTANT __string_43={__STRING_CONSTANT__,13,"\\bin;%path%\n\n"};
__STRING_CONSTANT __string_44={__STRING_CONSTANT__,36,"Installation of Lisaa\
c library path."};
__STRING_CONSTANT __string_45={__STRING_CONSTANT__,26,"#define LISAAC_DIRECT\
ORY \""};
__STRING_CONSTANT __string_46={__STRING_CONSTANT__,2,"\"\n"};
__STRING_CONSTANT __string_47={__STRING_CONSTANT__,10,"bin/path.h"};
__STRING_CONSTANT __string_48={__STRING_CONSTANT__,24,"#define LISAAC_DIRECT\
ORY"};
__STRING_CONSTANT __string_49={__STRING_CONSTANT__,10,"src/path.h"};
__STRING_CONSTANT __string_50={__STRING_CONSTANT__,40,"Installation of `lisa\
ac-mode' for Emacs."};
__STRING_CONSTANT __string_51={__STRING_CONSTANT__,67,"  Do you want to inst\
all the `lisaac-mode' for Emacs editor ? (y/n)"};
__STRING_CONSTANT __string_52={__STRING_CONSTANT__,47,"  Not install `lisaac\
-mode' for Emacs editor.\n\n"};
__STRING_CONSTANT __string_53={__STRING_CONSTANT__,2,"C:"};
__STRING_CONSTANT __string_54={__STRING_CONSTANT__,7,"/.emacs"};
__STRING_CONSTANT __string_55={__STRING_CONSTANT__,24,";; **** LISAAC MODE *\
***"};
__STRING_CONSTANT __string_56={__STRING_CONSTANT__,24,"\n(setq load-path (co\
ns \""};
__STRING_CONSTANT __string_57={__STRING_CONSTANT__,28,"/editor/emacs/\" load\
-path))\n"};
__STRING_CONSTANT __string_58={__STRING_CONSTANT__,133,"(add-to-list 'auto-m\
ode-alist '(\"\\\\.li\\\\'\" . lisaac-mode))\n(autoload 'lisaac-mode \"lisaa\
c-mode\" \"Major mode for Lisaac Programs\" t)\n\n"};
__STRING_CONSTANT __string_59={__STRING_CONSTANT__,41,"Installation of `lisa\
ac_v2.xml' for Kate."};
__STRING_CONSTANT __string_60={__STRING_CONSTANT__,39,"  Sorry, not Kate edi\
tor for windows.\n\n"};
__STRING_CONSTANT __string_61={__STRING_CONSTANT__,68,"  Do you want to inst\
all the `lisaac_v2.xml' for Kate editor ? (y/n)"};
__STRING_CONSTANT __string_62={__STRING_CONSTANT__,48,"  Not install `lisaac\
_v2.xml' for Kate editor.\n\n"};
__STRING_CONSTANT __string_63={__STRING_CONSTANT__,42,"mkdir -p ~/.kde/share\
/apps/katepart/syntax"};
__STRING_CONSTANT __string_64={__STRING_CONSTANT__,67,"cp -f editor/kate/lis\
aac_v2.xml ~/.kde/share/apps/katepart/syntax/."};
__STRING_CONSTANT __string_65={__STRING_CONSTANT__,3,"  `"};
__STRING_CONSTANT __string_66={__STRING_CONSTANT__,2,"'\t"};
__STRING_CONSTANT __string_67={__STRING_CONSTANT__,79,"\n  Sorry, auto-insta\
ll fail !\n  You can to read the `editor/kate/README' file.\n"};
__STRING_CONSTANT __string_68={__STRING_CONSTANT__,4,"OK.\n"};
__STRING_CONSTANT __string_69={__STRING_CONSTANT__,37,"Installation of `lisa\
ac.vim' for Vim."};
__STRING_CONSTANT __string_70={__STRING_CONSTANT__,38,"  Sorry, not Vim edit\
or for windows.\n\n"};
__STRING_CONSTANT __string_71={__STRING_CONSTANT__,66,"  Do you want to inst\
all the Lisaac support for Vim editor ? (y/n)"};
__STRING_CONSTANT __string_72={__STRING_CONSTANT__,44,"  Not install `lisaac\
.vim' for Vim editor.\n\n"};
__STRING_CONSTANT __string_73={__STRING_CONSTANT__,22,"mkdir -p ~/.vim/syntax"};
__STRING_CONSTANT __string_74={__STRING_CONSTANT__,22,"mkdir -p ~/.vim/indent"};
__STRING_CONSTANT __string_75={__STRING_CONSTANT__,22,"mkdir -p ~/.vim/backup"};
__STRING_CONSTANT __string_76={__STRING_CONSTANT__,20,"mkdir -p ~/.vim/temp"};
__STRING_CONSTANT __string_77={__STRING_CONSTANT__,49,"cp -f editor/vim/synt\
ax/lisaac.vim ~/.vim/syntax/"};
__STRING_CONSTANT __string_78={__STRING_CONSTANT__,90,"\n  Sorry, auto-insta\
ll fail !\n  You can read the `editor/vim/install_vim_plugin.sh' file.\n"};
__STRING_CONSTANT __string_79={__STRING_CONSTANT__,49,"cp -f editor/vim/inde\
nt/lisaac.vim ~/.vim/indent/"};
__STRING_CONSTANT __string_80={__STRING_CONSTANT__,302,"\n  It is recommande\
d to install the default vimrc file provided by the   \n  lisaac installer. \
                                                    \n\n  If you choose not \
doing this action, your vimrc will only be updated    \n  Do you want to ins\
tall the default config provided by lisaac installer? (y/n)"};
__STRING_CONSTANT __string_81={__STRING_CONSTANT__,7,"/.vimrc"};
__STRING_CONSTANT __string_82={__STRING_CONSTANT__,155,"\nsyntax on         \
                  \nfiletype plugin on                    \nfiletype indent \
on                    \nau BufNewFile,BufRead *.li setf lisaac\n"};
__STRING_CONSTANT __string_83={__STRING_CONSTANT__,31,"cp -f editor/vim/vimr\
c ~/.vimrc"};
__STRING_CONSTANT __string_84={__STRING_CONSTANT__,31,"Compilation of Lisaac\
 compiler."};
__STRING_CONSTANT __string_85={__STRING_CONSTANT__,6,"lisaac"};
__STRING_CONSTANT __string_86={__STRING_CONSTANT__,28,"Compilation of Shorte\
r tool."};
__STRING_CONSTANT __string_87={__STRING_CONSTANT__,7,"shorter"};
__STRING_CONSTANT __string_88={__STRING_CONSTANT__,31,"Build a librarie docu\
mentation."};
__STRING_CONSTANT __string_89={__STRING_CONSTANT__,60,"  Do you want to buil\
d a HTML librarie documentation ? (y/n)"};
__STRING_CONSTANT __string_90={__STRING_CONSTANT__,39,"  Not install librari\
e documentation.\n\n"};
__STRING_CONSTANT __string_91={__STRING_CONSTANT__,38,"bin\\shorter -r -f ht\
ml lib -o lib_html"};
__STRING_CONSTANT __string_92={__STRING_CONSTANT__,38,"bin/shorter -r -f htm\
l lib -o lib_html"};
__STRING_CONSTANT __string_93={__STRING_CONSTANT__,12,"  Execute: `"};
__STRING_CONSTANT __string_94={__STRING_CONSTANT__,2,"'\n"};
__STRING_CONSTANT __string_95={__STRING_CONSTANT__,60,"  OK, you found this \
documentation in `lib_html/index.html'\n"};
__STRING_CONSTANT __string_96={__STRING_CONSTANT__,29,"Welcome to the Lisaac\
 World !"};
__STRING_CONSTANT __string_97={__STRING_CONSTANT__,314,"  Installation succe\
ssfull.                               \n  Run `lisaac' to compile.          \
                    \n\n  Note: You'll have to reboot or reloaded environnem\
ent   \n        to acknowledge the changes.                       \n  Note: \
For bash users, doing a `source ~/.bashrc' should \n        do the job.\n"};
__STRING_CONSTANT __string_98={__STRING_CONSTANT__,5,"Step "};
__STRING_CONSTANT __string_99={__STRING_CONSTANT__,3," : "};
__STRING_CONSTANT __string_100={__STRING_CONSTANT__,1,"="};
__STRING_CONSTANT __string_101={__STRING_CONSTANT__,5,"  A `"};
__STRING_CONSTANT __string_102={__STRING_CONSTANT__,50,"' file has no need t\
o change. Current version is:\n"};
__STRING_CONSTANT __string_103={__STRING_CONSTANT__,39,"' file has been upda\
ted. Old value is:\n"};
__STRING_CONSTANT __string_104={__STRING_CONSTANT__,16,"  New value is:\n"};
__STRING_CONSTANT __string_105={__STRING_CONSTANT__,30,"' file has been upda\
ted with:\n"};
__STRING_CONSTANT __string_106={__STRING_CONSTANT__,30,"' file has been crea\
ted with:\n"};
__STRING_CONSTANT __string_107={__STRING_CONSTANT__,7,"Error: "};
__STRING_CONSTANT __string_108={__STRING_CONSTANT__,16,"Not create file!"};
__STRING_CONSTANT __string_109={__STRING_CONSTANT__,34,"Not open file (Write\
 protection) !"};
__STRING_CONSTANT __string_110={__STRING_CONSTANT__,12,"gcc -O2 bin/"};
__STRING_CONSTANT __string_111={__STRING_CONSTANT__,10,".c -o bin/"};
__STRING_CONSTANT __string_112={__STRING_CONSTANT__,19,"  Execute command `"};
__STRING_CONSTANT __string_113={__STRING_CONSTANT__,20,"' (please wait ...)\n"};
__STRING_CONSTANT __string_114={__STRING_CONSTANT__,51,"  Auto-install fail \
!\n  You want to compile a `bin/"};
__STRING_CONSTANT __string_115={__STRING_CONSTANT__,10,".c' file.\n"};
__STRING_CONSTANT __string_116={__STRING_CONSTANT__,19,"Not enough memory.\n"};

//==========================//
// FUNCTION HEADER          //
//==========================//

// Debug Manager
void print_string(char *str);
// Source code
static __STRING* create__ZB(__INTEGER needed_capacity__1B);
static void print__PB(__STRING_CONSTANT *Self__QB);
static __CHARACTER* to_external__2ID(__STRING *Self__3ID);
static void from_external__PKD(__STRING *Self__QKD,__CHARACTER *p__RKD);
static void copy__FMD(__STRING *Self__GMD,void *other__HMD);
static void* get_environment_variable__AC(void *variable__CC);
static void title__XC(void *str__ZC);
static __STRING* create_from_string__X1(void *str__Z1);
static __INTEGER first_substring_index__KVD(__STRING *Self__LVD,void *other__MVD);
static void append__TPD(__STRING *Self__UPD,void *other__VPD);
static void put_string__VU(void *s__XU);
static void update__idf__with__I2(void *file__K2,void *id__L2,void *new_text__M2);
static __INTEGER execute_command__VAB(void *system_command_line__XAB);
static void prepend__LOD(__STRING *Self__MOD,void *other__NOD);
static void replace_all__with__RTD(__STRING *Self__STD);
static void compile_file__KS(void *n__MS);
static __STRING* clone__0V();
static __CHARACTER* create__OQH(__INTEGER nb_elements__QQH);
static void add_last__ZNF(__STRING *Self__0NF,__CHARACTER ch__1NF);
static void copy_from__until__MPF(__CHARACTER *Self__NPF,__CHARACTER *model__OPF,__INTEGER upper__PPF);
static void print__IZ(__INTEGER Self__JZ);
static __CHARACTER* realloc__with__LRH(__CHARACTER *Self__MRH,__INTEGER old_nb_elts__NRH,__INTEGER new_nb_elts__ORH);
static void copy__to__until__YVJ(__CHARACTER *Self__ZVJ,__CHARACTER *src__0VJ,__INTEGER dest__1VJ,__INTEGER src_capacity__2VJ);
static __INTEGER fast_occurrences__until__SNC(__CHARACTER *Self__TNC,__INTEGER upper__VNC);
static void remove__QYF(__STRING *Self__RYF,__INTEGER index__SYF);
static void resize__WLE(__STRING *Self__XLE,__INTEGER new_count__YLE);
static void move__to__by__UUF(__CHARACTER *Self__VUF,__INTEGER lower__WUF,__INTEGER upper__XUF,__INTEGER offset__YUF);
static __POINTER micro_alloc__table__lab__1HC(__UINTEGER_32 new_size__3HC,__POINTER ptr_table__4HC,__UINTEGER_32 lab_type__5HC);
static void copy__to__size__XUB(__POINTER src__ZUB,__POINTER dst__0UB,__UINTEGER_32 sz__1UB);
static __POINTER alloc_dynamic__AAI(__UINTEGER_32 sz__CAI);
static void print_positif__3EL(__INTEGER Self__4EL);
static void to_busy__index__Z4J(__MEMORY *Self__04J,__UINTEGER_32 sz__14J,__UINTEGER_32 idx__24J);
static void* search__USI(__UINTEGER_32 new_size__WSI);
static void add_link_free__LRJ(__MEMORY *Self__MRJ);
static void delete_link_free__YNK(__MEMORY *Self__ZNK);
static void clear__to__M2J(__CHARACTER *Self__N2J,__INTEGER lower__O2J,__INTEGER upper__P2J);
static __POINTER new_lab__NXC(__UINTEGER_32 t__PXC);
static void* new_page__PKF();

//==========================//
// SOURCE CODE              //
//==========================//

int main(int argc,char **argv)
{
  __POINTER std_file__MD;
  void *new_text__OD,*file__PD,*file_name__XJ,*new_text__YJ;
  void *file_name__2N;
  void *comment__QD,*path__RD,*path_next__SD;
  __INTEGER result__UEQ;
  __STRING *Self__O1D;
  __CHARACTER *cwd__Y,*ptr__BWQ;
  __BOOLEAN __tmp__HE,__tmp__5E,result__HNB,__tmp__WF,result__UNB;
  __CHARACTER char__WJ,char__2L,char__1N,char__3S;
  arg_count  = argc;
  arg_vector = argv;
  parent_numeric__G=NUMERIC__;
  STRING_CONSTANT__->count__AD=((__INTEGER )((0)));
  STRING__->count__CB= 0;
  STRING_CONSTANT__->storage__KEC=((__CHARACTER *)(NULL));
  STRING__->storage__5JD=NULL;
  clone_allocation_size__TW= 0;
  nb_page__5XC= 0;
  MEMORY__->size_and_id__4W= 0;
  capacity_max__ZKF= 0;
  begin_memory__YJC=((__POINTER )(NULL));
  MEMORY__->previous_linear__3W= 0;
  first_free__XTI=NULL;
  MEMORY__->next_free__5W=NULL;
  MEMORY__->previous_free__AX=NULL;
  STRING__->capacity__CJD= 0;
  string_tmp__2=create__ZB( 256);
  path_current__GB=NULL;
  path_home__KB=NULL;
  shell__MB=NULL;
  step_count__0C= 0;
  system__FE=NULL;
  print__PB((&__string_1));
  ((__STRING *)string_tmp__2)->count__CB= 0;
  cwd__Y=to_external__2ID(string_tmp__2);
  getcwd((cwd__Y),255);
  from_external__PKD(string_tmp__2,cwd__Y);
  path_current__GB=create__ZB(((__STRING *)string_tmp__2)->count__CB);
  copy__FMD(path_current__GB,string_tmp__2);
  path_home__KB=get_environment_variable__AC((&__string_2));
  shell__MB=get_environment_variable__AC((&__string_3));
  title__XC((&__string_4));
  std_file__MD=((__POINTER )(NULL));
  new_text__OD=NULL;
  file__PD=NULL;
  comment__QD=NULL;
  path__RD=NULL;
  path_next__SD=NULL;
  if (((void *)shell__MB != (void *)NULL)) {
    file__PD=create_from_string__X1(path_home__KB);
    if ((((__STRING *)shell__MB)->count__CB ==  0)) {
      print__PB((&__string_5));
      system__FE=(&__string_6);
      __tmp__HE=TRUE__;
    } else {
      __tmp__HE=FALSE__;
    };
    if (__tmp__HE) {
      __tmp__5E=TRUE__;
    } else {
      result__HNB=(first_substring_index__KVD(((__STRING *)shell__MB),(&__string_7)) !=  0);
      if (result__HNB) {
        append__TPD(file__PD,(&__string_8));
        system__FE=(&__string_9);
        comment__QD=(&__string_10);
        path__RD=(&__string_11);
        path_next__SD=(&__string_12);
      };
      __tmp__5E=result__HNB;
    };
    if (__tmp__5E) {
      __tmp__WF=TRUE__;
    } else {
      result__UNB=(first_substring_index__KVD(((__STRING *)shell__MB),(&__string_13)) !=  0);
      if (result__UNB) {
        append__TPD(file__PD,(&__string_14));
        system__FE=(&__string_15);
        comment__QD=(&__string_10);
        path__RD=(&__string_16);
        path_next__SD=(&__string_17);
      };
      __tmp__WF=result__UNB;
    };
    if ((! __tmp__WF)) {
      if ((first_substring_index__KVD(((__STRING *)shell__MB),(&__string_18)) !=  0)) {
        append__TPD(file__PD,(&__string_19));
        system__FE=(&__string_20);
        comment__QD=(&__string_10);
        path__RD=(&__string_11);
        path_next__SD=(&__string_12);
      } else {
        print__PB((&__string_21));
        put_string__VU(((__STRING *)shell__MB));
        fputc((int)('\n'),stdout);
        system__FE=(&__string_6);
      };
    };
  } else {
    copy__FMD(string_tmp__2,(&__string_22));
    std_file__MD=((__POINTER )(fopen((char*)(to_external__2ID(string_tmp__2)),"rb")));
    if ((std_file__MD != (void *)NULL)) {
      fclose((FILE*)((std_file__MD)));
      file__PD=create_from_string__X1((&__string_22));
      system__FE=(&__string_23);
      comment__QD=(&__string_24);
      path__RD=(&__string_25);
      path_next__SD=(&__string_26);
    } else {
      system__FE=(&__string_6);
    };
  };
  print__PB((&__string_27));
  print__PB(system__FE);
  fputc((int)('\n'),stdout);
  if (((void *)system__FE != (void *)(&__string_6))) {
    if (((void *)system__FE == (void *)(&__string_23))) {
      update__idf__with__I2((&__string_28),(&__string_29),(&__string_30));
      print__PB((&__string_31));
    } else {
      update__idf__with__I2((&__string_28),(&__string_29),(&__string_32));
      print__PB((&__string_33));
      execute_command__VAB((&__string_34));
      copy__FMD(string_tmp__2,(&__string_35));
      std_file__MD=((__POINTER )(fopen((char*)(to_external__2ID(string_tmp__2)),"rb")));
      fseek((FILE*)((std_file__MD)),0,SEEK_END);
      result__UEQ=((__INTEGER )(ftell((FILE *)(std_file__MD))));
      fseek((FILE*)((std_file__MD)),0,SEEK_SET);
      if ((result__UEQ ==  0)) {
        print__PB((&__string_36));
      } else {
        new_text__OD=create__ZB(result__UEQ);
        ptr__BWQ=to_external__2ID(new_text__OD);
        fread((void *)((ptr__BWQ)),(size_t)(1), (size_t)((result__UEQ)),(FILE*)((std_file__MD)));
        from_external__PKD(new_text__OD,ptr__BWQ);
        Self__O1D=((__STRING *)new_text__OD);
        if (( 10 > Self__O1D->count__CB)) {
          Self__O1D->count__CB= 0;
        } else {
          Self__O1D->count__CB=(__INTEGER)(Self__O1D->count__CB -  10);
        };
        prepend__LOD(new_text__OD,(&__string_37));
        append__TPD(new_text__OD,(&__string_38));
        update__idf__with__I2((&__string_28),(&__string_39),new_text__OD);
      };
      fclose((FILE*)((std_file__MD)));
      execute_command__VAB((&__string_40));
    };
  };
  fputc((int)('\n'),stdout);
  title__XC((&__string_41));
  if (((void *)system__FE == (void *)(&__string_6))) {
    print__PB((&__string_42));
    put_string__VU(((__STRING *)path_current__GB));
    print__PB((&__string_43));
  } else {
    new_text__OD=create_from_string__X1(comment__QD);
    append__TPD(new_text__OD,path__RD);
    append__TPD(new_text__OD,path_current__GB);
    append__TPD(new_text__OD,path_next__SD);
    update__idf__with__I2(file__PD,comment__QD,new_text__OD);
  };
  title__XC((&__string_44));
  new_text__OD=create_from_string__X1(path_current__GB);
  if (((void *)system__FE == (void *)(&__string_23))) {
    replace_all__with__RTD(new_text__OD);
  };
  prepend__LOD(new_text__OD,(&__string_45));
  append__TPD(new_text__OD,(&__string_46));
  update__idf__with__I2((&__string_47),(&__string_48),new_text__OD);
  fputc((int)('\n'),stdout);
  update__idf__with__I2((&__string_49),(&__string_48),new_text__OD);
  fputc((int)('\n'),stdout);
  title__XC((&__string_50));
  char__WJ='\0';
  file_name__XJ=NULL;
  new_text__YJ=NULL;
  print__PB((&__string_51));
  while (((char__WJ != 'y') && (char__WJ != 'n'))) {
    char__WJ=((__CHARACTER )(fgetc(stdin)));
  };
  if ((char__WJ == 'n')) {
    print__PB((&__string_52));
  } else {
    file_name__XJ=create__ZB( 100);
    if (((void *)path_home__KB == (void *)NULL)) {
      copy__FMD(file_name__XJ,(&__string_53));
    } else {
      copy__FMD(file_name__XJ,path_home__KB);
    };
    append__TPD(file_name__XJ,(&__string_54));
    new_text__YJ=create_from_string__X1((&__string_55));
    append__TPD(new_text__YJ,(&__string_56));
    append__TPD(new_text__YJ,path_current__GB);
    if (((void *)system__FE == (void *)(&__string_23))) {
      replace_all__with__RTD(new_text__YJ);
    };
    append__TPD(new_text__YJ,(&__string_57));
    append__TPD(new_text__YJ,(&__string_58));
    update__idf__with__I2(file_name__XJ,(&__string_55),new_text__YJ);
  };
  title__XC((&__string_59));
  char__2L='\0';
  if (((void *)system__FE == (void *)(&__string_23))) {
    print__PB((&__string_60));
  } else {
    print__PB((&__string_61));
    while (((char__2L != 'y') && (char__2L != 'n'))) {
      char__2L=((__CHARACTER )(fgetc(stdin)));
    };
    if ((char__2L == 'n')) {
      print__PB((&__string_62));
    } else {
      execute_command__VAB((&__string_63));
      copy__FMD(string_tmp__2,(&__string_64));
      print__PB((&__string_65));
      put_string__VU(((__STRING *)string_tmp__2));
      print__PB((&__string_66));
      if ((execute_command__VAB(string_tmp__2) !=  0)) {
        print__PB((&__string_67));
      } else {
        print__PB((&__string_68));
      };
    };
    fputc((int)('\n'),stdout);
  };
  title__XC((&__string_69));
  char__1N='\0';
  file_name__2N=NULL;
  if (((void *)system__FE == (void *)(&__string_23))) {
    print__PB((&__string_70));
  } else {
    print__PB((&__string_71));
    while (((char__1N != 'y') && (char__1N != 'n'))) {
      char__1N=((__CHARACTER )(fgetc(stdin)));
    };
    if ((char__1N == 'n')) {
      print__PB((&__string_72));
    } else {
      execute_command__VAB((&__string_73));
      execute_command__VAB((&__string_74));
      execute_command__VAB((&__string_75));
      execute_command__VAB((&__string_76));
      copy__FMD(string_tmp__2,(&__string_77));
      print__PB((&__string_65));
      put_string__VU(((__STRING *)string_tmp__2));
      print__PB((&__string_66));
      if ((execute_command__VAB(string_tmp__2) !=  0)) {
        print__PB((&__string_78));
      } else {
        print__PB((&__string_68));
      };
      copy__FMD(string_tmp__2,(&__string_79));
      print__PB((&__string_65));
      put_string__VU(((__STRING *)string_tmp__2));
      print__PB((&__string_66));
      if ((execute_command__VAB(string_tmp__2) !=  0)) {
        print__PB((&__string_78));
      } else {
        print__PB((&__string_68));
      };
      char__1N='?';
      print__PB((&__string_80));
      while (((char__1N != 'y') && (char__1N != 'n'))) {
        char__1N=((__CHARACTER )(fgetc(stdin)));
      };
      if ((char__1N == 'n')) {
        file_name__2N=create__ZB( 100);
        if (((void *)path_home__KB == (void *)NULL)) {
          copy__FMD(file_name__2N,(&__string_53));
        } else {
          copy__FMD(file_name__2N,path_home__KB);
        };
        append__TPD(file_name__2N,(&__string_81));
        update__idf__with__I2(file_name__2N,(&__string_82),(&__string_82));
      } else {
        copy__FMD(string_tmp__2,(&__string_83));
        print__PB((&__string_65));
        put_string__VU(((__STRING *)string_tmp__2));
        print__PB((&__string_66));
        if ((execute_command__VAB(string_tmp__2) !=  0)) {
          print__PB((&__string_78));
        } else {
          print__PB((&__string_68));
        };
      };
    };
    fputc((int)('\n'),stdout);
  };
  title__XC((&__string_84));
  compile_file__KS((&__string_85));
  title__XC((&__string_86));
  compile_file__KS((&__string_87));
  title__XC((&__string_88));
  char__3S='\0';
  print__PB((&__string_89));
  while (((char__3S != 'y') && (char__3S != 'n'))) {
    char__3S=((__CHARACTER )(fgetc(stdin)));
  };
  if ((char__3S == 'n')) {
    print__PB((&__string_90));
  } else {
    ((__STRING *)string_tmp__2)->count__CB= 0;
    if (((void *)system__FE == (void *)(&__string_23))) {
      copy__FMD(string_tmp__2,(&__string_91));
    } else {
      copy__FMD(string_tmp__2,(&__string_92));
    };
    print__PB((&__string_93));
    put_string__VU(((__STRING *)string_tmp__2));
    print__PB((&__string_94));
    execute_command__VAB(string_tmp__2);
    print__PB((&__string_95));
  };
  fputc((int)('\n'),stdout);
  title__XC((&__string_96));
  print__PB((&__string_97));
  return( 0);
}

static __STRING* create__ZB(__INTEGER needed_capacity__1B)
// ({INTEGER}) With resultNo recursive, No inlinable.
{
  __STRING *result__3B,*Self__PND;
  result__3B=clone__0V();
  Self__PND=((__STRING *)result__3B);
  if ((needed_capacity__1B >  0)) {
    if ((Self__PND->capacity__CJD < needed_capacity__1B)) {
      Self__PND->storage__5JD=create__OQH(needed_capacity__1B);
      Self__PND->capacity__CJD=needed_capacity__1B;
    };
  };
  Self__PND->count__CB= 0;
  return(result__3B);
}

static void print__PB(__STRING_CONSTANT *Self__QB)
// ({STRING_CONSTANT}) VoidRecursive, No inlinable.
{
  put_string__VU(Self__QB);
}

static __CHARACTER* to_external__2ID(__STRING *Self__3ID)
// ({STRING}) With resultNo recursive, No inlinable.
{
  if ((Self__3ID->capacity__CJD > Self__3ID->count__CB)) {
    Self__3ID->count__CB=(__INTEGER)(Self__3ID->count__CB +  1);
    if ((((__CHARACTER *)Self__3ID->storage__5JD)[(__INTEGER)(Self__3ID->count__CB -  1)] != '\0')) {
      ((__CHARACTER *)Self__3ID->storage__5JD)[(__INTEGER)(Self__3ID->count__CB -  1)]='\0';
    };
  } else {
    add_last__ZNF(Self__3ID,'\0');
  };
  Self__3ID->count__CB=(__INTEGER)(Self__3ID->count__CB -  1);
  return(Self__3ID->storage__5JD);
}

static void from_external__PKD(__STRING *Self__QKD,__CHARACTER *p__RKD)
// ({STRING},{NULLxNATIVE_ARRAYoExpanded_CHARACTERo}) VoidNo recursive, No inlinable.
{
  Self__QKD->count__CB= 0;
  while ((((__CHARACTER *)p__RKD)[Self__QKD->count__CB] != '\0')) {
    Self__QKD->count__CB=(__INTEGER)(Self__QKD->count__CB +  1);
  };
  if (((void *)Self__QKD->storage__5JD != (void *)p__RKD)) {
    Self__QKD->storage__5JD=p__RKD;
    Self__QKD->capacity__CJD=(__INTEGER)(Self__QKD->count__CB +  1);
  };
}

static void copy__FMD(__STRING *Self__GMD,void *other__HMD)
// ({STRING},{NULLxSTRING_CONSTANTxSTRING}) VoidNo recursive, No inlinable.
{
  __INTEGER __tmp__IMD;
  __CHARACTER *__tmp__3MD,*__tmp__5MD;
  if (((struct ___OBJ *)other__HMD)->__id==__STRING_CONSTANT__) {
    __tmp__IMD=((__STRING_CONSTANT *)other__HMD)->count__AD;
  } else {
    __tmp__IMD=((__STRING *)other__HMD)->count__CB;
  };
  Self__GMD->count__CB=__tmp__IMD;
  if ((__tmp__IMD >  0)) {
    if ((Self__GMD->capacity__CJD < __tmp__IMD)) {
      Self__GMD->storage__5JD=create__OQH(__tmp__IMD);
      Self__GMD->capacity__CJD=Self__GMD->count__CB;
    };
    __tmp__3MD=Self__GMD->storage__5JD;
    if (((struct ___OBJ *)other__HMD)->__id==__STRING_CONSTANT__) {
      __tmp__5MD=((__STRING_CONSTANT *)other__HMD)->storage__KEC;
    } else {
      __tmp__5MD=((__STRING *)other__HMD)->storage__5JD;
    };
    copy_from__until__MPF(__tmp__3MD,__tmp__5MD,(__INTEGER)(Self__GMD->count__CB -  1));
  };
}

static void* get_environment_variable__AC(void *variable__CC)
// ({STRING_CONSTANT}) With resultNo recursive, No inlinable.
{
  void *result__EC;
  __STRING *new__CYQ;
  __CHARACTER *p__FC;
  result__EC=NULL;
  new__CYQ=create__ZB(((__STRING_CONSTANT *)variable__CC)->count__AD);
  copy__FMD(new__CYQ,variable__CC);
  p__FC=((__CHARACTER *)(getenv((char*)(to_external__2ID(new__CYQ)))));
  if (((void *)p__FC != (void *)NULL)) {
    result__EC=clone__0V();
    from_external__PKD(result__EC,p__FC);
  };
  return(result__EC);
}

static void title__XC(void *str__ZC)
// ({STRING_CONSTANT}) VoidNo recursive, No inlinable.
{
  __INTEGER Self__O0,limit_up__P0;
  step_count__0C=(__INTEGER)(step_count__0C +  1);
  print__PB((&__string_98));
  print__IZ(step_count__0C);
  fputc((int)('/'),stdout);
  print__IZ( 10);
  print__PB((&__string_99));
  print__PB(str__ZC);
  fputc((int)('\n'),stdout);
  Self__O0= 1;
  limit_up__P0=(__INTEGER)(((__STRING_CONSTANT *)str__ZC)->count__AD +  11);
  while ((Self__O0 <= limit_up__P0)) {
    print__PB((&__string_100));
    Self__O0=(__INTEGER)(Self__O0 +  1);
  };
  fputc((int)('\n'),stdout);
}

static __STRING* create_from_string__X1(void *str__Z1)
// ({NULLxSTRING_CONSTANTxSTRING}) With resultNo recursive, No inlinable.
{
  __INTEGER __tmp__21;
  __STRING *result__11;
  if (((struct ___OBJ *)str__Z1)->__id==__STRING_CONSTANT__) {
    __tmp__21=((__STRING_CONSTANT *)str__Z1)->count__AD;
  } else {
    __tmp__21=((__STRING *)str__Z1)->count__CB;
  };
  result__11=create__ZB(__tmp__21);
  copy__FMD(result__11,str__Z1);
  return(result__11);
}

static __INTEGER first_substring_index__KVD(__STRING *Self__LVD,void *other__MVD)
// ({STRING},{NULLxSTRING_CONSTANT}) With resultNo recursive, No inlinable.
{
  __INTEGER i__2RE,result__4RE,s__3RE;
  i__2RE= 0;
  result__4RE= 0;
  s__3RE= 1;
  while ((! ((result__4RE !=  0) || ((__INTEGER)((__INTEGER)(s__3RE + ((__STRING_CONSTANT *)other__MVD)->count__AD) -  1) > Self__LVD->count__CB)))) {
    i__2RE= 1;
    while ((! ((i__2RE > ((__STRING_CONSTANT *)other__MVD)->count__AD) || (((__CHARACTER *)Self__LVD->storage__5JD)[(__INTEGER)((__INTEGER)((__INTEGER)(s__3RE + i__2RE) -  1) -  1)] != ((__CHARACTER *)((__STRING_CONSTANT *)other__MVD)->storage__KEC)[(__INTEGER)(i__2RE -  1)])))) {
      i__2RE=(__INTEGER)(i__2RE +  1);
    };
    if ((i__2RE > ((__STRING_CONSTANT *)other__MVD)->count__AD)) {
      result__4RE=s__3RE;
    } else {
      s__3RE=(__INTEGER)(s__3RE +  1);
    };
  };
  return(result__4RE);
}

static void append__TPD(__STRING *Self__UPD,void *other__VPD)
// ({STRING},{NULLxSTRING_CONSTANTxSTRING}) VoidNo recursive, No inlinable.
{
  __INTEGER __tmp__4PD,needed_capacity__XPD;
  __CHARACTER *__tmp__1QD,*__tmp__2QD;
  if (((struct ___OBJ *)other__VPD)->__id==__STRING_CONSTANT__) {
    __tmp__4PD=((__STRING_CONSTANT *)other__VPD)->count__AD;
  } else {
    __tmp__4PD=((__STRING *)other__VPD)->count__CB;
  };
  needed_capacity__XPD=(__INTEGER)(Self__UPD->count__CB + __tmp__4PD);
  if ((Self__UPD->capacity__CJD < needed_capacity__XPD)) {
    if ((Self__UPD->capacity__CJD ==  0)) {
      Self__UPD->capacity__CJD=needed_capacity__XPD;
      Self__UPD->storage__5JD=create__OQH(needed_capacity__XPD);
    } else {
      Self__UPD->storage__5JD=realloc__with__LRH(Self__UPD->storage__5JD,Self__UPD->capacity__CJD,needed_capacity__XPD);
      Self__UPD->capacity__CJD=needed_capacity__XPD;
    };
  };
  __tmp__1QD=Self__UPD->storage__5JD;
  if (((struct ___OBJ *)other__VPD)->__id==__STRING_CONSTANT__) {
    __tmp__2QD=((__STRING_CONSTANT *)other__VPD)->storage__KEC;
  } else {
    __tmp__2QD=((__STRING *)other__VPD)->storage__5JD;
  };
  copy__to__until__YVJ(__tmp__1QD,__tmp__2QD,Self__UPD->count__CB,__tmp__4PD);
  Self__UPD->count__CB=needed_capacity__XPD;
}

static void put_string__VU(void *s__XU)
// ({STRING_CONSTANTxSTRING}) VoidNo recursive, No inlinable.
{
  __INTEGER __tmp__KV,Self__RDB,limit_up__SDB;
  __CHARACTER __tmp__RV;
  if (((struct ___OBJ *)s__XU)->__id==__STRING_CONSTANT__) {
  };
  if (((struct ___OBJ *)s__XU)->__id==__STRING_CONSTANT__) {
    __tmp__KV=((__STRING_CONSTANT *)s__XU)->count__AD;
  } else {
    __tmp__KV=((__STRING *)s__XU)->count__CB;
  };
  Self__RDB= 1;
  limit_up__SDB=__tmp__KV;
  while ((Self__RDB <= limit_up__SDB)) {
    if (((struct ___OBJ *)s__XU)->__id==__STRING_CONSTANT__) {
      __tmp__RV=((__CHARACTER *)((__STRING_CONSTANT *)s__XU)->storage__KEC)[(__INTEGER)(Self__RDB -  1)];
    } else {
      __tmp__RV=((__CHARACTER *)((__STRING *)s__XU)->storage__5JD)[(__INTEGER)(Self__RDB -  1)];
    };
    fputc((int)(__tmp__RV),stdout);
    Self__RDB=(__INTEGER)(Self__RDB +  1);
  };
}

static void update__idf__with__I2(void *file__K2,void *id__L2,void *new_text__M2)
// ({NULLxSTRING_CONSTANTxSTRING},{NULLxSTRING_CONSTANT},{NULLxSTRING_CONSTANTxSTRING}) VoidNo recursive, No inlinable.
{
  __INTEGER index__N2,result__ZWB,__tmp__02,__tmp__G3,Self__SEC;
  __INTEGER limit_up__TEC,__tmp__C0D,__tmp__D0D,__tmp__X0D,i__3WG;
  __INTEGER j__5VD,__tmp__SWD;
  void *old_buffer__O2,*input__P2;
  __POINTER std_file__Q2,stream__UXB;
  __STRING_CONSTANT *Self__HEC,*Self__ZZQ,*Self__2ZQ;
  __STRING *Self__GZQ,*Self__YZD,*Self__2VD,*new__0ZQ,*__tmp__Y4;
  __STRING *new__3ZQ,*__tmp__04;
  __CHARACTER *ptr__CXB,*__tmp__U0D,*__tmp__V0D,*Self__JWG,*other__KWG;
  __CHARACTER *__tmp__CXD,*__tmp__DXD;
  __BOOLEAN result__1ZD,result__WXB;
  index__N2= 0;
  old_buffer__O2=NULL;
  input__P2=NULL;
  print__PB((&__string_101));
  if (((struct ___OBJ *)file__K2)->__id==__STRING_CONSTANT__) {
    print__PB(file__K2);
  } else {
    put_string__VU(((__STRING *)file__K2));
  };
  copy__FMD(string_tmp__2,file__K2);
  std_file__Q2=((__POINTER )(fopen((char*)(to_external__2ID(string_tmp__2)),"rb")));
  if ((std_file__Q2 != (void *)NULL)) {
    fseek((FILE*)((std_file__Q2)),0,SEEK_END);
    result__ZWB=((__INTEGER )(ftell((FILE *)(std_file__Q2))));
    fseek((FILE*)((std_file__Q2)),0,SEEK_SET);
    if (((struct ___OBJ *)new_text__M2)->__id==__STRING_CONSTANT__) {
      __tmp__02=((__STRING_CONSTANT *)new_text__M2)->count__AD;
    } else {
      __tmp__02=((__STRING *)new_text__M2)->count__CB;
    };
    input__P2=create__ZB((__INTEGER)(result__ZWB + __tmp__02));
    ptr__CXB=to_external__2ID(input__P2);
    fread((void *)((ptr__CXB)),(size_t)(1), (size_t)((result__ZWB)),(FILE*)((std_file__Q2)));
    from_external__PKD(input__P2,ptr__CXB);
    fclose((FILE*)((std_file__Q2)));
    index__N2=first_substring_index__KVD(input__P2,id__L2);
    if ((index__N2 !=  0)) {
      old_buffer__O2=create__ZB( 200);
      if (((struct ___OBJ *)new_text__M2)->__id==__STRING_CONSTANT__) {
        Self__HEC=((__STRING_CONSTANT *)new_text__M2);
        __tmp__G3=fast_occurrences__until__SNC(Self__HEC->storage__KEC,(__INTEGER)(Self__HEC->count__AD -  1));
      } else {
        Self__GZQ=((__STRING *)new_text__M2);
        __tmp__G3=fast_occurrences__until__SNC(Self__GZQ->storage__5JD,(__INTEGER)(Self__GZQ->count__CB -  1));
      };
      Self__SEC= 1;
      limit_up__TEC=__tmp__G3;
      while ((Self__SEC <= limit_up__TEC)) {
        while ((((__CHARACTER *)((__STRING *)input__P2)->storage__5JD)[(__INTEGER)(index__N2 -  1)] != '\n')) {
          add_last__ZNF(old_buffer__O2,((__CHARACTER *)((__STRING *)input__P2)->storage__5JD)[(__INTEGER)(index__N2 -  1)]);
          remove__QYF(input__P2,index__N2);
        };
        add_last__ZNF(old_buffer__O2,((__CHARACTER *)((__STRING *)input__P2)->storage__5JD)[(__INTEGER)(index__N2 -  1)]);
        remove__QYF(input__P2,index__N2);
        Self__SEC=(__INTEGER)(Self__SEC +  1);
      };
      Self__YZD=((__STRING *)old_buffer__O2);
      result__1ZD=FALSE__;
      __tmp__C0D=Self__YZD->count__CB;
      if (((struct ___OBJ *)new_text__M2)->__id==__STRING_CONSTANT__) {
        __tmp__D0D=((__STRING_CONSTANT *)new_text__M2)->count__AD;
      } else {
        __tmp__D0D=((__STRING *)new_text__M2)->count__CB;
      };
      if ((__tmp__C0D == __tmp__D0D)) {
        if ((Self__YZD->count__CB ==  0)) {
          result__1ZD=TRUE__;
        } else {
          __tmp__U0D=Self__YZD->storage__5JD;
          if (((struct ___OBJ *)new_text__M2)->__id==__STRING_CONSTANT__) {
            __tmp__V0D=((__STRING_CONSTANT *)new_text__M2)->storage__KEC;
          } else {
            __tmp__V0D=((__STRING *)new_text__M2)->storage__5JD;
          };
          __tmp__X0D=Self__YZD->count__CB;
          Self__JWG=((__CHARACTER *)__tmp__U0D);
          other__KWG=__tmp__V0D;
          i__3WG=(__INTEGER)(__tmp__X0D -  1);
          while (((i__3WG >=  0) && (Self__JWG[i__3WG] == ((__CHARACTER *)other__KWG)[i__3WG]))) {
            i__3WG=(__INTEGER)(i__3WG -  1);
          };
          result__1ZD=(i__3WG <  0);
        };
      };
      if (result__1ZD) {
        print__PB((&__string_102));
      } else {
        print__PB((&__string_103));
        put_string__VU(((__STRING *)old_buffer__O2));
        print__PB((&__string_104));
      };
    } else {
      print__PB((&__string_105));
      index__N2=(__INTEGER)(((__STRING *)input__P2)->count__CB +  1);
    };
    if (((struct ___OBJ *)new_text__M2)->__id==__STRING_CONSTANT__) {
      print__PB(new_text__M2);
    } else {
      put_string__VU(((__STRING *)new_text__M2));
    };
    Self__2VD=((__STRING *)input__P2);
    j__5VD=Self__2VD->count__CB;
    if (((struct ___OBJ *)new_text__M2)->__id==__STRING_CONSTANT__) {
      __tmp__SWD=((__STRING_CONSTANT *)new_text__M2)->count__AD;
    } else {
      __tmp__SWD=((__STRING *)new_text__M2)->count__CB;
    };
    resize__WLE(Self__2VD,(__INTEGER)(j__5VD + __tmp__SWD));
    if ((index__N2 <= j__5VD)) {
      move__to__by__UUF(Self__2VD->storage__5JD,(__INTEGER)(index__N2 -  1),(__INTEGER)(j__5VD -  1),__tmp__SWD);
    };
    __tmp__CXD=Self__2VD->storage__5JD;
    if (((struct ___OBJ *)new_text__M2)->__id==__STRING_CONSTANT__) {
      __tmp__DXD=((__STRING_CONSTANT *)new_text__M2)->storage__KEC;
    } else {
      __tmp__DXD=((__STRING *)new_text__M2)->storage__5JD;
    };
    copy__to__until__YVJ(__tmp__CXD,__tmp__DXD,(__INTEGER)(index__N2 -  1),__tmp__SWD);
  } else {
    print__PB((&__string_106));
    if (((struct ___OBJ *)new_text__M2)->__id==__STRING_CONSTANT__) {
      print__PB(new_text__M2);
    } else {
      put_string__VU(((__STRING *)new_text__M2));
    };
    if (((struct ___OBJ *)new_text__M2)->__id==__STRING_CONSTANT__) {
      Self__ZZQ=((__STRING_CONSTANT *)new_text__M2);
      new__0ZQ=create__ZB(Self__ZZQ->count__AD);
      copy__FMD(new__0ZQ,Self__ZZQ);
      __tmp__Y4=new__0ZQ;
    } else {
      __tmp__Y4=create_from_string__X1(((__STRING *)new_text__M2));
    };
    input__P2=__tmp__Y4;
    if (((struct ___OBJ *)file__K2)->__id==__STRING_CONSTANT__) {
      Self__2ZQ=((__STRING_CONSTANT *)file__K2);
      new__3ZQ=create__ZB(Self__2ZQ->count__AD);
      copy__FMD(new__3ZQ,Self__2ZQ);
      __tmp__04=new__3ZQ;
    } else {
      __tmp__04=create_from_string__X1(((__STRING *)file__K2));
    };
    stream__UXB=((__POINTER )(fopen((char*)(to_external__2ID(__tmp__04)),"w+b")));
    result__WXB=(stream__UXB != (void *)NULL);
    if (result__WXB) {
      fclose((FILE*)((stream__UXB)));
    };
    if ((! result__WXB)) {
      print__PB((&__string_107));
      print__PB((&__string_108));
      exit(( 1));
    };
  };
  copy__FMD(string_tmp__2,file__K2);
  std_file__Q2=((__POINTER )(fopen((char*)(to_external__2ID(string_tmp__2)),"wb")));
  if ((std_file__Q2 == (void *)NULL)) {
    print__PB((&__string_107));
    print__PB((&__string_109));
    exit(( 1));
  };
  fwrite((void *)((to_external__2ID(input__P2))),(size_t)(1), (size_t)((((__STRING *)input__P2)->count__CB)),(FILE*)((std_file__Q2)));
  fclose((FILE*)((std_file__Q2)));
}

static __INTEGER execute_command__VAB(void *system_command_line__XAB)
// ({NULLxSTRING_CONSTANTxSTRING}) With resultNo recursive, No inlinable.
{
  __STRING_CONSTANT *Self__NY;
  __STRING *new__5FB;
  __CHARACTER *__tmp__5AB;
  if (((struct ___OBJ *)system_command_line__XAB)->__id==__STRING_CONSTANT__) {
    Self__NY=((__STRING_CONSTANT *)system_command_line__XAB);
    new__5FB=create__ZB(Self__NY->count__AD);
    copy__FMD(new__5FB,Self__NY);
    __tmp__5AB=to_external__2ID(new__5FB);
  } else {
    __tmp__5AB=to_external__2ID(system_command_line__XAB);
  };
  return(((__INTEGER )(system(((char*)((__tmp__5AB)))))));
}

static void prepend__LOD(__STRING *Self__MOD,void *other__NOD)
// ({STRING},{STRING_CONSTANT}) VoidNo recursive, No inlinable.
{
  __INTEGER i__OOD,j__POD;
  i__OOD=Self__MOD->count__CB;
  j__POD=((__STRING_CONSTANT *)other__NOD)->count__AD;
  resize__WLE(Self__MOD,(__INTEGER)(i__OOD + j__POD));
  if (((i__OOD >  0) && (j__POD >  0))) {
    move__to__by__UUF(Self__MOD->storage__5JD, 0,(__INTEGER)(i__OOD -  1),j__POD);
  };
  copy_from__until__MPF(Self__MOD->storage__5JD,((__STRING_CONSTANT *)other__NOD)->storage__KEC,(__INTEGER)(j__POD -  1));
}

static void replace_all__with__RTD(__STRING *Self__STD)
// ({STRING}) VoidNo recursive, No inlinable.
{
  __INTEGER __tmp__0TD,Self__SGK;
  __CHARACTER *__tmp__XTD,*Self__3WJ;
  __tmp__XTD=Self__STD->storage__5JD;
  __tmp__0TD=(__INTEGER)(Self__STD->count__CB -  1);
  Self__3WJ=((__CHARACTER *)__tmp__XTD);
  Self__SGK=__tmp__0TD;
  while ((Self__SGK >=  0)) {
    if (('\\' == Self__3WJ[Self__SGK])) {
      Self__3WJ[Self__SGK]='/';
    };
    Self__SGK=(__INTEGER)(Self__SGK -  1);
  };
}

static void compile_file__KS(void *n__MS)
// ({STRING_CONSTANT}) VoidNo recursive, No inlinable.
{
  copy__FMD(string_tmp__2,(&__string_110));
  append__TPD(string_tmp__2,n__MS);
  append__TPD(string_tmp__2,(&__string_111));
  append__TPD(string_tmp__2,n__MS);
  print__PB((&__string_112));
  put_string__VU(((__STRING *)string_tmp__2));
  print__PB((&__string_113));
  if ((execute_command__VAB(string_tmp__2) !=  0)) {
    print__PB((&__string_114));
    print__PB(n__MS);
    print__PB((&__string_115));
  };
  fputc((int)('\n'),stdout);
}

static __STRING* clone__0V()
// () With resultNo recursive, No inlinable.
{
  __STRING *result__3V;
  __POINTER ptr__4V;
  __INTEGER typ_id__FW;
  __UINTEGER_32 sz__CW,a__FBS,new_size__HAC,t__QBC,a__JBS,a__MBS;
  result__3V=NULL;
  ptr__4V=((__POINTER )(NULL));
  typ_id__FW= 0;
  sz__CW=((__UINTEGER_32 )sizeof(__STRING));
  if ((sz__CW ==  0)) {
    result__3V=STRING__;
  } else {
    typ_id__FW=-1;
    clone_allocation_size__TW=(__UINTEGER_32)(clone_allocation_size__TW + sz__CW);
    if ((typ_id__FW == (__INTEGER)(-  1))) {
      a__FBS=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
      new_size__HAC=(__UINTEGER_32)((__UINTEGER_32)(sz__CW + a__FBS) & (__UINTEGER_32)(~ a__FBS));
      ptr__4V=micro_alloc__table__lab__1HC(new_size__HAC,((__POINTER )(&(table_size[((__UINTEGER_32)(new_size__HAC / ((__UINTEGER_32 )((__INTEGER )(sizeof(void *))))))-1]))),new_size__HAC);
    } else {
      t__QBC=((__UINTEGER_32 )typ_id__FW);
      a__JBS=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
      ptr__4V=micro_alloc__table__lab__1HC((__UINTEGER_32)((__UINTEGER_32)(sz__CW + a__JBS) & (__UINTEGER_32)(~ a__JBS)),((__POINTER )(&(table_type[(t__QBC)]))),(__UINTEGER_32)(t__QBC |  1));
    };
    a__MBS=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
    copy__to__size__XUB(((__POINTER )STRING__),ptr__4V,(__UINTEGER_32)((__UINTEGER_32)(sz__CW + a__MBS) & (__UINTEGER_32)(~ a__MBS)));
    result__3V=((__STRING *)ptr__4V);
  };
  return(result__3V);
}

static __CHARACTER* create__OQH(__INTEGER nb_elements__QQH)
// ({INTEGER}) With resultNo recursive, No inlinable.
{
  __INTEGER Self__ZHK;
  __CHARACTER *Result__JWH;
  Result__JWH=((__CHARACTER *)alloc_dynamic__AAI(((__UINTEGER_32 )nb_elements__QQH)));
  Self__ZHK=(__INTEGER)(nb_elements__QQH -  1);
  while ((Self__ZHK >=  0)) {
    Result__JWH[Self__ZHK]='\0';
    Self__ZHK=(__INTEGER)(Self__ZHK -  1);
  };
  return(Result__JWH);
}

static void add_last__ZNF(__STRING *Self__0NF,__CHARACTER ch__1NF)
// ({STRING},{CHARACTER}) VoidNo recursive, No inlinable.
{
  __INTEGER new_capacity__2NF;
  new_capacity__2NF= 0;
  if ((Self__0NF->capacity__CJD <= Self__0NF->count__CB)) {
    if ((Self__0NF->capacity__CJD ==  0)) {
      Self__0NF->capacity__CJD= 32;
      Self__0NF->storage__5JD=create__OQH( 32);
    } else {
      new_capacity__2NF=(__INTEGER)(Self__0NF->capacity__CJD <<  1);
      Self__0NF->storage__5JD=realloc__with__LRH(Self__0NF->storage__5JD,Self__0NF->capacity__CJD,new_capacity__2NF);
      Self__0NF->capacity__CJD=new_capacity__2NF;
    };
  };
  ((__CHARACTER *)Self__0NF->storage__5JD)[Self__0NF->count__CB]=ch__1NF;
  Self__0NF->count__CB=(__INTEGER)(Self__0NF->count__CB +  1);
}

static void copy_from__until__MPF(__CHARACTER *Self__NPF,__CHARACTER *model__OPF,__INTEGER upper__PPF)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{NULLxNATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER}) VoidNo recursive, No inlinable.
{
  __INTEGER Self__TCG;
  Self__TCG=upper__PPF;
  while ((Self__TCG >=  0)) {
    Self__NPF[Self__TCG]=((__CHARACTER *)model__OPF)[Self__TCG];
    Self__TCG=(__INTEGER)(Self__TCG -  1);
  };
}

static void print__IZ(__INTEGER Self__JZ)
// ({INTEGER}) VoidNo recursive, No inlinable.
{
  __BOOLEAN __tmp__QZ;
  if ((Self__JZ ==  0)) {
    fputc((int)('0'),stdout);
    __tmp__QZ=TRUE__;
  } else {
    __tmp__QZ=FALSE__;
  };
  if ((! __tmp__QZ)) {
    if ((Self__JZ <  0)) {
      fputc((int)('-'),stdout);
      print_positif__3EL((__INTEGER)(- Self__JZ));
    } else {
      print_positif__3EL(Self__JZ);
    };
  };
}

static __CHARACTER* realloc__with__LRH(__CHARACTER *Self__MRH,__INTEGER old_nb_elts__NRH,__INTEGER new_nb_elts__ORH)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER},{INTEGER}) With resultNo recursive, No inlinable.
{
  __POINTER old_ptr__FSH,result__K1H,p__ZMI,last__JXI;
  __UINTEGER_32 __tmp__RSH,__tmp__TSH,a__YBS,old_size__A1H;
  __UINTEGER_32 old_size2__D1H,a__1BS,new_size__G1H,a__MUB,__tmp__12H;
  __UINTEGER_32 sz__VOI,old_size__SOI,prev__SIJ,new_size__VIJ;
  void *mem__J1H,*nxt__QOI,*result__ROI,*next__RIJ,*new_free__QIJ;
  __MEMORY *Self__MOI;
  __CHARACTER *new__ESH;
  old_ptr__FSH=((__POINTER )Self__MRH);
  __tmp__RSH=((__UINTEGER_32 )old_nb_elts__NRH);
  __tmp__TSH=((__UINTEGER_32 )new_nb_elts__ORH);
  mem__J1H=NULL;
  result__K1H=((__POINTER )(NULL));
  a__YBS=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
  old_size__A1H=(__UINTEGER_32)((__UINTEGER_32)(__tmp__RSH + a__YBS) & (__UINTEGER_32)(~ a__YBS));
  old_size2__D1H=(__UINTEGER_32)(old_size__A1H + ((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))));
  a__1BS=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
  new_size__G1H=(__UINTEGER_32)((__UINTEGER_32)(__tmp__TSH + a__1BS) & (__UINTEGER_32)(~ a__1BS));
  if ((old_size2__D1H <= ((__UINTEGER_32 )(MINIMUM_SIZE)))) {
    result__K1H=alloc_dynamic__AAI(new_size__G1H);
    copy__to__size__XUB(old_ptr__FSH,result__K1H,old_size__A1H);
    p__ZMI=(void *)((unsigned long)old_ptr__FSH - (unsigned long)((__POINTER )((__INTEGER )(sizeof(void *)))));
    a__MUB=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
    last__JXI=((__POINTER *)((__POINTER )(&(table_size[((__UINTEGER_32)((__UINTEGER_32)((__UINTEGER_32)(old_size2__D1H + a__MUB) & (__UINTEGER_32)(~ a__MUB)) / ((__UINTEGER_32 )((__INTEGER )(sizeof(void *))))))-1]))))[ 0];
    ((__POINTER *)p__ZMI)[ 0]=(void *)((unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)(void *)((unsigned long)(void *)((unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER *)last__JXI)[ 0]) - (unsigned long)((__POINTER ) 1)) & (unsigned long)(void *)((unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 3)) - (unsigned long)((__POINTER ) 1)))) - (unsigned long)((__POINTER ) 1));
    ((__POINTER *)last__JXI)[ 0]=p__ZMI;
  } else {
    mem__J1H=((void *)(void *)((unsigned long)old_ptr__FSH - (unsigned long)((__POINTER ) 8)));
    __tmp__12H=(__UINTEGER_32)(((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)old_ptr__FSH - (unsigned long)begin_memory__YJC)))) >>  26);
    Self__MOI=((__MEMORY *)mem__J1H);
    nxt__QOI=NULL;
    result__ROI=NULL;
    sz__VOI= 0;
    old_size__SOI=(__UINTEGER_32)(Self__MOI->size_and_id__4W &  4294967292LU);
    if ((new_size__G1H > old_size__SOI)) {
      if ((! ((__UINTEGER_32)(Self__MOI->size_and_id__4W &  2) !=  0))) {
        nxt__QOI=((void *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__MOI) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__MOI->size_and_id__4W &  4294967292LU)))));
        sz__VOI=(__UINTEGER_32)((__UINTEGER_32)(new_size__G1H - old_size__SOI) -  8);
        if ((((__UINTEGER_32)(((__MEMORY *)nxt__QOI)->size_and_id__4W &  1) ==  0) && ((__UINTEGER_32)(((__MEMORY *)nxt__QOI)->size_and_id__4W &  4294967292LU) >= sz__VOI))) {
          to_busy__index__Z4J(nxt__QOI,sz__VOI,__tmp__12H);
          Self__MOI->size_and_id__4W=(__UINTEGER_32)((__UINTEGER_32)(Self__MOI->size_and_id__4W + (__UINTEGER_32)(((__MEMORY *)nxt__QOI)->size_and_id__4W &  4294967294LU)) +  8);
          if (((__UINTEGER_32)(Self__MOI->size_and_id__4W &  2) !=  0)) {
            last_block[(__tmp__12H)] = (Self__MOI);
          } else {
            nxt__QOI=((void *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__MOI) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__MOI->size_and_id__4W &  4294967292LU)))));
            ((__MEMORY *)nxt__QOI)->previous_linear__3W=((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)((__POINTER )Self__MOI) - (unsigned long)begin_memory__YJC))));
          };
          result__ROI=Self__MOI;
        };
      };
      if (((void *)result__ROI == (void *)NULL)) {
        result__ROI=search__USI(new_size__G1H);
        copy__to__size__XUB((void *)((unsigned long)((__POINTER )Self__MOI) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))),(void *)((unsigned long)((__POINTER )((__MEMORY *)result__ROI)) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))),old_size__SOI);
        prev__SIJ=Self__MOI->previous_linear__3W;
        next__RIJ=((void *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__MOI) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__MOI->size_and_id__4W &  4294967292LU)))));
        new_free__QIJ=((void *)(void *)((unsigned long)begin_memory__YJC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )prev__SIJ))));
        new_size__VIJ=(__UINTEGER_32)(Self__MOI->size_and_id__4W &  4294967294LU);
        if (((prev__SIJ ==  4294967295LU) || ((__UINTEGER_32)(((__MEMORY *)new_free__QIJ)->size_and_id__4W &  1) !=  0))) {
          new_free__QIJ=Self__MOI;
          add_link_free__LRJ(Self__MOI);
        } else {
          new_size__VIJ=(__UINTEGER_32)((__UINTEGER_32)(new_size__VIJ + ((__MEMORY *)new_free__QIJ)->size_and_id__4W) +  8);
        };
        if (((! ((__UINTEGER_32)(Self__MOI->size_and_id__4W &  2) !=  0)) && ((__UINTEGER_32)(((__MEMORY *)next__RIJ)->size_and_id__4W &  1) ==  0))) {
          new_size__VIJ=(__UINTEGER_32)((__UINTEGER_32)(new_size__VIJ + ((__MEMORY *)next__RIJ)->size_and_id__4W) +  8);
          delete_link_free__YNK(next__RIJ);
        };
        ((__MEMORY *)new_free__QIJ)->size_and_id__4W=new_size__VIJ;
        if (((__UINTEGER_32)(((__MEMORY *)new_free__QIJ)->size_and_id__4W &  2) !=  0)) {
          last_block[(__tmp__12H)] = (new_free__QIJ);
        } else {
          next__RIJ=((void *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__MOI) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__MOI->size_and_id__4W &  4294967292LU)))));
          ((__MEMORY *)next__RIJ)->previous_linear__3W=((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)((__POINTER )new_free__QIJ) - (unsigned long)begin_memory__YJC))));
        };
      };
    } else {
      result__ROI=Self__MOI;
    };
    result__K1H=(void *)((unsigned long)((__POINTER )((__MEMORY *)result__ROI)) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8)));
  };
  new__ESH=((__CHARACTER *)result__K1H);
  clear__to__M2J(new__ESH,old_nb_elts__NRH,(__INTEGER)(new_nb_elts__ORH -  1));
  return(new__ESH);
}

static void copy__to__until__YVJ(__CHARACTER *Self__ZVJ,__CHARACTER *src__0VJ,__INTEGER dest__1VJ,__INTEGER src_capacity__2VJ)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{NULLxNATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER},{INTEGER}) VoidNo recursive, No inlinable.
{
  __INTEGER i2__MWJ,i1__LWJ;
  i2__MWJ= 0;
  i1__LWJ=dest__1VJ;
  while ((i2__MWJ != src_capacity__2VJ)) {
    Self__ZVJ[i1__LWJ]=((__CHARACTER *)src__0VJ)[i2__MWJ];
    i2__MWJ=(__INTEGER)(i2__MWJ +  1);
    i1__LWJ=(__INTEGER)(i1__LWJ +  1);
  };
}

static __INTEGER fast_occurrences__until__SNC(__CHARACTER *Self__TNC,__INTEGER upper__VNC)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER}) With resultNo recursive, No inlinable.
{
  __INTEGER count__5NC,Self__TUC;
  count__5NC= 0;
  Self__TUC=upper__VNC;
  while ((Self__TUC >=  0)) {
    if (('\n' == Self__TNC[Self__TUC])) {
      count__5NC=(__INTEGER)(count__5NC +  1);
    };
    Self__TUC=(__INTEGER)(Self__TUC -  1);
  };
  return(count__5NC);
}

static void remove__QYF(__STRING *Self__RYF,__INTEGER index__SYF)
// ({STRING},{INTEGER}) VoidNo recursive, No inlinable.
{
  __INTEGER __tmp__UJG,__tmp__VJG,Self__IOH;
  __tmp__UJG=(__INTEGER)(index__SYF +  1);
  __tmp__VJG=Self__RYF->count__CB;
  Self__IOH=__tmp__UJG;
  while ((Self__IOH <= __tmp__VJG)) {
    ((__CHARACTER *)Self__RYF->storage__5JD)[(__INTEGER)((__INTEGER)(Self__IOH -  1) -  1)]=((__CHARACTER *)Self__RYF->storage__5JD)[(__INTEGER)(Self__IOH -  1)];
    Self__IOH=(__INTEGER)(Self__IOH +  1);
  };
  Self__RYF->count__CB=(__INTEGER)(Self__RYF->count__CB -  1);
}

static void resize__WLE(__STRING *Self__XLE,__INTEGER new_count__YLE)
// ({STRING},{INTEGER}) VoidNo recursive, No inlinable.
{
  if ((! (new_count__YLE <= Self__XLE->count__CB))) {
    if ((Self__XLE->capacity__CJD < new_count__YLE)) {
      if ((Self__XLE->capacity__CJD ==  0)) {
        Self__XLE->storage__5JD=create__OQH(new_count__YLE);
      } else {
        Self__XLE->storage__5JD=realloc__with__LRH(Self__XLE->storage__5JD,Self__XLE->capacity__CJD,new_count__YLE);
      };
      Self__XLE->capacity__CJD=new_count__YLE;
    } else {
      clear__to__M2J(Self__XLE->storage__5JD,Self__XLE->count__CB,(__INTEGER)(new_count__YLE -  1));
    };
  };
  Self__XLE->count__CB=new_count__YLE;
}

static void move__to__by__UUF(__CHARACTER *Self__VUF,__INTEGER lower__WUF,__INTEGER upper__XUF,__INTEGER offset__YUF)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER},{INTEGER},{INTEGER}) VoidNo recursive, No inlinable.
{
  __INTEGER Self__EYK,Self__TYK;
  if ((offset__YUF !=  0)) {
    if ((offset__YUF <  0)) {
      Self__EYK=lower__WUF;
      while ((Self__EYK <= upper__XUF)) {
        Self__VUF[(__INTEGER)(Self__EYK + offset__YUF)]=Self__VUF[Self__EYK];
        Self__EYK=(__INTEGER)(Self__EYK +  1);
      };
    } else {
      Self__TYK=upper__XUF;
      while ((Self__TYK >= lower__WUF)) {
        Self__VUF[(__INTEGER)(Self__TYK + offset__YUF)]=Self__VUF[Self__TYK];
        Self__TYK=(__INTEGER)(Self__TYK -  1);
      };
    };
  };
}

static __POINTER micro_alloc__table__lab__1HC(__UINTEGER_32 new_size__3HC,__POINTER ptr_table__4HC,__UINTEGER_32 lab_type__5HC)
// ({UINTEGER_32},{POINTER},{UINTEGER_32}) With resultNo recursive, No inlinable.
{
  __POINTER next__DIC,result__BIC;
  next__DIC=((__POINTER )(NULL));
  result__BIC=((__POINTER *)ptr_table__4HC)[ 0];
  if ((result__BIC == (void *)NULL)) {
    result__BIC=new_lab__NXC(lab_type__5HC);
    next__DIC=(void *)((unsigned long)result__BIC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )new_size__3HC)));
    ((__POINTER *)next__DIC)[ 0]=NULL;
    ((__POINTER *)ptr_table__4HC)[ 0]=next__DIC;
  } else {
    next__DIC=((__POINTER *)result__BIC)[ 0];
    if ((next__DIC == (void *)NULL)) {
      if (((__UINTEGER_32)((__UINTEGER_32)(((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)result__BIC - (unsigned long)begin_memory__YJC)))) &  4095) + (__UINTEGER_32)(new_size__3HC <<  1)) <=  4096)) {
        next__DIC=(void *)((unsigned long)result__BIC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )new_size__3HC)));
      } else {
        next__DIC=new_lab__NXC(lab_type__5HC);
      };
      ((__POINTER *)next__DIC)[ 0]=NULL;
      ((__POINTER *)ptr_table__4HC)[ 0]=next__DIC;
    } else {
      ((__POINTER *)result__BIC)[ 0]=(void *)((unsigned long)((__POINTER *)next__DIC)[ 0] & (unsigned long)((__POINTER )(__INTEGER)(~  3)));
      result__BIC=next__DIC;
    };
  };
  return(result__BIC);
}

static void copy__to__size__XUB(__POINTER src__ZUB,__POINTER dst__0UB,__UINTEGER_32 sz__1UB)
// ({POINTER},{POINTER},{UINTEGER_32}) VoidNo recursive, No inlinable.
{
  __INTEGER siz__AVB,Self__A2B;
  __POINTER *na_src__4UB,*na_dst__5UB;
  siz__AVB=((__INTEGER )sz__1UB);
  na_src__4UB=((__POINTER *)src__ZUB);
  na_dst__5UB=((__POINTER *)dst__0UB);
  Self__A2B=(__INTEGER)((__INTEGER)(siz__AVB / ((__INTEGER )(sizeof(void *)))) -  1);
  while ((Self__A2B >=  0)) {
    na_dst__5UB[Self__A2B]=na_src__4UB[Self__A2B];
    Self__A2B=(__INTEGER)(Self__A2B -  1);
  };
}

static __POINTER alloc_dynamic__AAI(__UINTEGER_32 sz__CAI)
// ({UINTEGER_32}) With resultNo recursive, No inlinable.
{
  __POINTER result__KAI;
  __UINTEGER_32 a__M5R,new_size__EAI,new_size2__HAI,a__R5R;
  __UINTEGER_32 new_size__P5R;
  result__KAI=((__POINTER )(NULL));
  a__M5R=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
  new_size__EAI=(__UINTEGER_32)((__UINTEGER_32)(sz__CAI + a__M5R) & (__UINTEGER_32)(~ a__M5R));
  new_size2__HAI=(__UINTEGER_32)(new_size__EAI + ((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))));
  if ((new_size2__HAI <= ((__UINTEGER_32 )(MINIMUM_SIZE)))) {
    a__R5R=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
    new_size__P5R=(__UINTEGER_32)((__UINTEGER_32)(new_size2__HAI + a__R5R) & (__UINTEGER_32)(~ a__R5R));
    result__KAI=micro_alloc__table__lab__1HC(new_size__P5R,((__POINTER )(&(table_size[((__UINTEGER_32)(new_size__P5R / ((__UINTEGER_32 )((__INTEGER )(sizeof(void *))))))-1]))),new_size__P5R);
    ((__POINTER *)result__KAI)[ 0]=((__POINTER ) 3);
    result__KAI=(void *)((unsigned long)result__KAI - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )((__INTEGER )(sizeof(void *))))));
  } else {
    result__KAI=(void *)((unsigned long)((__POINTER )((__MEMORY *)search__USI(new_size__EAI))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8)));
  };
  return(result__KAI);
}

static void print_positif__3EL(__INTEGER Self__4EL)
// ({INTEGER}) VoidRecursive, No inlinable.
{
  __INTEGER val__HFL;
  __CHARACTER Result__Z3L;
  Result__Z3L=((__CHARACTER )(((__INTEGER_8)(((__INTEGER_8 )(__INTEGER)(Self__4EL %  10)) + ((__INTEGER_8 )'0')))));
  val__HFL=(__INTEGER)(Self__4EL /  10);
  if ((val__HFL !=  0)) {
    print_positif__3EL(val__HFL);
  };
  fputc((int)(Result__Z3L),stdout);
}

static void to_busy__index__Z4J(__MEMORY *Self__04J,__UINTEGER_32 sz__14J,__UINTEGER_32 idx__24J)
// ({MEMORY},{UINTEGER_32},{UINTEGER_32}) VoidNo recursive, No inlinable.
{
  void *new__D5J;
  __UINTEGER_32 siz__34J,new_size__A5J;
  __MEMORY *Self__EPR;
  new__D5J=NULL;
  delete_link_free__YNK(Self__04J);
  siz__34J=Self__04J->size_and_id__4W;
  new_size__A5J=(__UINTEGER_32)(siz__34J - sz__14J);
  if ((new_size__A5J > (__UINTEGER_32)((__UINTEGER_32)(((__UINTEGER_32 )(MINIMUM_SIZE)) +  2) +  8))) {
    siz__34J=sz__14J;
    new__D5J=((void *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__04J) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )sz__14J))));
    ((__MEMORY *)new__D5J)->previous_linear__3W=((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)((__POINTER )Self__04J) - (unsigned long)begin_memory__YJC))));
    ((__MEMORY *)new__D5J)->size_and_id__4W=(__UINTEGER_32)(new_size__A5J -  8);
    add_link_free__LRJ(new__D5J);
    if (((__UINTEGER_32)(((__MEMORY *)new__D5J)->size_and_id__4W &  2) !=  0)) {
      last_block[(idx__24J)] = (new__D5J);
    } else {
      Self__EPR=((__MEMORY *)new__D5J);
      ((__MEMORY *)((void *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__EPR) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__EPR->size_and_id__4W &  4294967292LU))))))->previous_linear__3W=((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)((__POINTER )((__MEMORY *)new__D5J)) - (unsigned long)begin_memory__YJC))));
    };
  };
  Self__04J->size_and_id__4W=(__UINTEGER_32)(siz__34J |  1);
}

static void* search__USI(__UINTEGER_32 new_size__WSI)
// ({UINTEGER_32}) With resultNo recursive, No inlinable.
{
  void *result__YSI;
  result__YSI=first_free__XTI;
  while ((((void *)result__YSI != (void *)NULL) && ((__UINTEGER_32)(((__MEMORY *)result__YSI)->size_and_id__4W &  4294967292LU) < new_size__WSI))) {
    result__YSI=((__MEMORY *)result__YSI)->next_free__5W;
  };
  if (((void *)result__YSI == (void *)NULL)) {
    result__YSI=new_page__PKF();
  };
  to_busy__index__Z4J(result__YSI,new_size__WSI,(__UINTEGER_32)(((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)((__POINTER )((__MEMORY *)result__YSI)) - (unsigned long)begin_memory__YJC)))) >>  26));
  return(result__YSI);
}

static void add_link_free__LRJ(__MEMORY *Self__MRJ)
// ({MEMORY}) VoidNo recursive, No inlinable.
{
  Self__MRJ->next_free__5W=first_free__XTI;
  Self__MRJ->previous_free__AX=NULL;
  if (((void *)first_free__XTI != (void *)NULL)) {
    ((__MEMORY *)first_free__XTI)->previous_free__AX=Self__MRJ;
  };
  first_free__XTI=Self__MRJ;
}

static void delete_link_free__YNK(__MEMORY *Self__ZNK)
// ({MEMORY}) VoidNo recursive, No inlinable.
{
  void *prev__0NK,*next__1NK;
  prev__0NK=Self__ZNK->previous_free__AX;
  next__1NK=Self__ZNK->next_free__5W;
  if (((void *)prev__0NK == (void *)NULL)) {
    first_free__XTI=next__1NK;
  } else {
    ((__MEMORY *)prev__0NK)->next_free__5W=next__1NK;
  };
  if (((void *)next__1NK != (void *)NULL)) {
    ((__MEMORY *)next__1NK)->previous_free__AX=prev__0NK;
  };
}

static void clear__to__M2J(__CHARACTER *Self__N2J,__INTEGER lower__O2J,__INTEGER upper__P2J)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER},{INTEGER}) VoidNo recursive, No inlinable.
{
  __INTEGER Self__YJK;
  Self__YJK=lower__O2J;
  while ((Self__YJK <= upper__P2J)) {
    Self__N2J[Self__YJK]='\0';
    Self__YJK=(__INTEGER)(Self__YJK +  1);
  };
}

static __POINTER new_lab__NXC(__UINTEGER_32 t__PXC)
// ({UINTEGER_32}) With resultNo recursive, No inlinable.
{
  __UINTEGER_32 idx__RXC,pv__YXC;
  void *blc__UXC,*prev__VXC;
  __MEMORY *Self__ETR;
  __POINTER result__WXC;
  __BOOLEAN __tmp__YYC;
  idx__RXC= 0;
  blc__UXC=NULL;
  prev__VXC=NULL;
  pv__YXC= 0;
  while_do__Q2C:
  {
    if ((idx__RXC < nb_page__5XC)) {
      blc__UXC=((void *)(last_block[(idx__RXC)]));
      __tmp__YYC=(((__UINTEGER_32)(((__MEMORY *)blc__UXC)->size_and_id__4W &  4294967292LU) <  4096) || ((__UINTEGER_32)(((__MEMORY *)blc__UXC)->size_and_id__4W &  1) ==  1));
    } else {
      __tmp__YYC=FALSE__;
    };
    if (__tmp__YYC) {
      idx__RXC=(__UINTEGER_32)(idx__RXC +  1);
      goto while_do__Q2C;
    };
  };
  if ((idx__RXC >= nb_page__5XC)) {
    blc__UXC=new_page__PKF();
  };
  ((__MEMORY *)blc__UXC)->size_and_id__4W=(__UINTEGER_32)(((__MEMORY *)blc__UXC)->size_and_id__4W -  4096);
  Self__ETR=((__MEMORY *)blc__UXC);
  result__WXC=((__POINTER )((void *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__ETR) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__ETR->size_and_id__4W &  4294967292LU))))));
  if (((__UINTEGER_32)(((__MEMORY *)blc__UXC)->size_and_id__4W &  4294967292LU) < ((__UINTEGER_32 )(MINIMUM_SIZE)))) {
    delete_link_free__YNK(blc__UXC);
    pv__YXC=((__MEMORY *)blc__UXC)->previous_linear__3W;
    if ((pv__YXC !=  4294967295LU)) {
      prev__VXC=((void *)(void *)((unsigned long)begin_memory__YJC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )pv__YXC))));
      ((__MEMORY *)prev__VXC)->size_and_id__4W=(__UINTEGER_32)((__UINTEGER_32)(((__MEMORY *)prev__VXC)->size_and_id__4W + ((__MEMORY *)blc__UXC)->size_and_id__4W) +  8);
      last_block[(idx__RXC)] = (prev__VXC);
    };
  };
  ((__POINTER *)result__WXC)[ 0]=((__POINTER )t__PXC);
  return((void *)((unsigned long)result__WXC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )((__INTEGER )(sizeof(void *)))))));
}

static void* new_page__PKF()
// () With resultNo recursive, No inlinable.
{
  __POINTER mem__R2G;
  __UINTEGER_32 cap__O2G,old_size__SKF;
  void *block__YKF;
  if ((capacity_max__ZKF ==  0)) {
    mem__R2G=((__POINTER )(NULL));
    cap__O2G= 33554432;
    do {
      cap__O2G=(__UINTEGER_32)(cap__O2G <<  1);
      mem__R2G=((__POINTER )(malloc((cap__O2G))));
      if ((mem__R2G != (void *)NULL)) {
        free((mem__R2G));
      };
    } while ((! ((mem__R2G == (void *)NULL) || (cap__O2G ==  2147483648LU))));
    if ((mem__R2G == (void *)NULL)) {
      cap__O2G=(__UINTEGER_32)(cap__O2G >>  1);
    };
    capacity_max__ZKF=cap__O2G;
    begin_memory__YJC=((__POINTER )(malloc((cap__O2G))));
  };
  old_size__SKF=(__UINTEGER_32)(nb_page__5XC <<  26);
  nb_page__5XC=(__UINTEGER_32)(nb_page__5XC +  1);
  if (((__UINTEGER_32)(old_size__SKF +  67108864) > capacity_max__ZKF)) {
    print__PB((&__string_116));
    exit(( 1));
  };
  block__YKF=((void *)(void *)((unsigned long)begin_memory__YJC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )old_size__SKF))));
  ((__MEMORY *)block__YKF)->previous_linear__3W= 4294967295LU;
  ((__MEMORY *)block__YKF)->size_and_id__4W= 67108858;
  add_link_free__LRJ(block__YKF);
  last_block[((__UINTEGER_32)(nb_page__5XC -  1))] = (block__YKF);
  return(block__YKF);
}

//==========================//
// DEBUG MANAGER            //
//==========================//

void print_string(char *str) 
{ 
  while (*str!=0) {
    print_char(*str); 
    str++; 
  };
}  

