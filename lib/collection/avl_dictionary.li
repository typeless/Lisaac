////////////////////////////////////////////////////////////////////////////////
//                            Lisaac Librairy                                 //
//                                                                            //
//                  LSIIT - ULP - CNRS - INRIA - FRANCE                       //
//                                                                            //
//    This program is free software; you can redistribute it and/or modify    //
//    it under the terms of the CeCILL v2 License as published by the         //
//    CEA - CNRS - INRIA.                                                     //
//                                                                            //
//    This program is distributed in the hope that it will be useful,         //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            //
//    CeCILL v2 License for more details.                                     //
//                                                                            //
//    You should have received a copy of the CeCILL v2 license along with     //
//    this program.                                                           //
//    If not, see <http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt>  //
//                                                                            //
//                    http://isaacproject.u-strasbg.fr/                       //
////////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name := AVL_DICTIONARY[V, K];
  
  - comment := "Associative memory. Values of type `V' are stored using Keys of type `K'.";
	
  // Efficient implementation of DICTIONARY using an AVL balanced tree. 
  // AVL stands for the names of G. M. Adel'son-Velskii and E. M. Landis, 
  // two Russian mathematicians who first came up with this method of keeping 
  // the tree balanced.

Section Inherit
  
  + parent_simple_dictionary:Expanded SIMPLE_DICTIONARY[V, K];

Section Insert
  
  + parent_avl_tree:Expanded AVL_TREE[K];
  
Section Private
  
  - key_memory:E <- item_memory;
		
Section Public
  
  - capacity:INTEGER <- count;

  - at k:K :V <- root.at(k).value;

  - fast_at k:K :V <- root.fast_at k.value;

  - reference_at k:K :V <-
  ( + result:V;
    + n:AVL_DICTIONARY_NODE[V, K];
    
    (root != NULL).if {
      n := root.at k;
      (n != NULL).if {
	result := n.value;
      };
    };
    result
  );

  - fast_reference_at k:K :V <-
  ( + result:V;
    + n:AVL_DICTIONARY_NODE[V, K];
		
    (root != NULL).if {
      n := root.fast_at k;
      (n != NULL).if {
	result := n.value;
      };
    };
    result
  );
  
  - put v:V to k:K <- add v to k;
  
  - add v:V to k:K <-
  (
    value_memory := v;
    key_memory := k;
    root := do_insert root;
  );

  - fast_put v:V to k:K <-
  (
    value_memory := v;
    key_memory := k;
    root := fast_do_insert root;
  );

  - occurrences v:V :INTEGER <-
  ( + result:INTEGER;
    
    (root != NULL).if {
      result := root.occurrences v;
    };
    result
  );

  - fast_occurrences v:V :INTEGER <-
  ( + result:INTEGER;
    
    (root != NULL).if {
      result := root.fast_occurrences v;
    };
    result
  );

  - key_at v:V :K <- root.key_at v;
		
  - fast_key_at v:V :K <- root.fast_key_at v;

  - clear_count <- clear_count_and_capacity;

  - clear_count_and_capacity <-
  (
    (! is_empty).if {
      clear_nodes root;
      root := NULL;
      count := 0;
      map_dirty := TRUE;
    };
  );

  - item index:INTEGER :V <-
  (
    (map_dirty).if {
      build_map;
    };
    map.item (index - 1).value
  );

  - key index:INTEGER :K <-
  (
    (map_dirty).if {
      build_map;
    };
    map.item (index - 1).key
  );

  - internal_key k:K :K <- root.at(k).key;

Section Private
  
  + value_memory:V;

  - set_value_and_key n:AVL_DICTIONARY_NODE[V, K] <-
  (
    n.make (value_memory, key_memory);
  );

  - set_value n:AVL_DICTIONARY_NODE[V, K] <-
  (
    n.set_value value_memory;
  );

  - exchange_and_discard (n1, n2:AVL_TREE_NODE[E]) <-
  (
    n1.set_key (n2.key);
    n1.set_value (n2.value);
    rebalance := TRUE;
    count := count - 1;
    discard_node n2;
  );

  - discard_node n:AVL_DICTIONARY_NODE[V, K] <-
  ( + v:V;
    + k:K;
		
    n.make (v, k);
  );

  - a_new_node:AVL_DICTIONARY_NODE[V, K] <-
  (
    AVL_DICTIONARY_NODE[V, K].create 
  );
  
  - create:SELF <-
  ( + result:SELF;
    
    result := clone;
    result.make;
    result
  );
  
  - make <-
  (
    create map.make 0;
    // lost_nodes ::= common_lost_nodes.reference_at(generating_type)
    // if lost_nodes = NULL then
    //	create lost_nodes.set_item(NULL)
    //	common_lost_nodes.add(lost_nodes, generating_type)
    //end
  );
  
  //		
  //invariant
  //
  
  //[ ...
   // -? {lost_nodes != NULL};
   // -? {lost_nodes = common_lost_nodes.at generating_type};
  //]

