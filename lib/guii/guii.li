///////////////////////////////////////////////////////////////////////////////
//                             Lisaac Library                                //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name      := GUII;
  
  - copyright := "Jonathan Ponte, Maxime Audrin, Benoit Sonntag";
  
Section Inherit
  
  - parent_object:OBJECT := OBJECT;
  
Section Private

  - internal_create a:INODE screen_width w:INTEGER screen_height h:INTEGER<-
  (
    root:=a;
    screen_width:=w;
    screen_height:=h;
  );
  
Section Public
  
  + root:INODE;
  + screen_width:INTEGER;
  + screen_height:INTEGER;
  + placement:G_EXPR;
  

  - create a:INODE screen_width w:INTEGER screen_height h:INTEGER :GUII<-
  (
    +result:SELF;
    
    result:=clone;
    result.internal_create a screen_width w screen_height h;
    result
  );
  
  - run_interface <-
  (
    make_placement;

    VIDEO.make (screen_width,screen_height);

    DESK.make VIDEO with placement;
  );
  

  - set_depth base:INODE from j:INTEGER <-
  (
	+dpth:INTEGER;
	
	dpth:=j+1;
	base.list.foreach{
		i:INODE;
		i.set_depth dpth;
		(!i.list.is_empty).if {
			set_depth i from dpth;
		};
	};
    );		

  - get_height l:LINKED_LIST[LINKED_LIST[G_EXPR]] :INTEGER<-
  (
    +result:INTEGER;

    l.foreach {
      i:LINKED_LIST[G_EXPR];
      +max_height:INTEGER;

      i.foreach {
        j:G_EXPR;

        (max_height<j.height_min).if {
          max_height:=j.height_min;
        };
      };
      result:=result+max_height;
      max_height:=0;
    };
    result
  );

  - get_width l:LINKED_LIST[LINKED_LIST[G_EXPR]] :INTEGER<-
  (
    +result:INTEGER;

    l.foreach {
      i:LINKED_LIST[G_EXPR];
      +tmp:INTEGER;

      tmp:=get_width_row i;
      (tmp > result).if {
        result:=tmp;
      };
    };
    result
  );

  - get_width_row l:LINKED_LIST[G_EXPR] :INTEGER<-
  (
    +result:INTEGER;
    l.foreach {
      g:G_EXPR;
      result:=result+g.width_min;
    };
    result
  );

  - move_widget row:LINKED_LIST[G_EXPR] to next_row:LINKED_LIST[G_EXPR] <-
  (
    +g:G_EXPR;
     g:=row.last;
     next_row.add_first g;
     row.remove_last;
  );

  - widget_placement :INTEGER <-
  (
    +width_max:INTEGER;
    +widget_min_width:INTEGER;	//widget with minimum width
    +widget_max_width:INTEGER;	//widget with maximum width
    +widgets_height:INTEGER;	//sum of the maximum widget height per row
    +rows:LINKED_LIST[LINKED_LIST[G_EXPR]];
    +width_opt:INTEGER;
    +area:INTEGER;

    rows:=LINKED_LIST[LINKED_LIST[G_EXPR]].create;
    widget_min_width:=root.list.first.content.width_min;
    rows.add_first (LINKED_LIST[G_EXPR].create);

    root.list.foreach {
       node:INODE;
       rows.first.add_last (node.content);
       (widget_max_width<node.content.width_min).if {
         widget_max_width:=node.content.width_min;
       };
       (widget_min_width>node.content.width_min).if {
         widget_min_width:=node.content.width_min;
       };
    };
    rows.add_last (LINKED_LIST[G_EXPR].create);

    widgets_height:=get_height rows;
    width_max:=screen_width;

    {(widget_max_width<width_max) && {widgets_height<screen_height}}.while_do {
        +row:LINKED_LIST[G_EXPR];
        +next_row:LINKED_LIST[G_EXPR];
        +row_width:INTEGER;

        rows.lower.to (rows.upper-1) do {
          i:INTEGER;

          row:=rows.item i;
          next_row:=rows.item (i+1);
          row_width:=get_width_row row;
          {(row_width>width_max) && {row.count>1}}.while_do {
            move_widget row to next_row;
          };
          (((get_width_row next_row)>width_max) && {i=rows.count-1}).if {
            rows.add_last (LINKED_LIST[G_EXPR].create);
          };
        };

        (area=0).if {
          width_opt:=get_width rows;
          area:=width_opt*(get_height rows);
        } else {
          +tmp:INTEGER;
          +tmp_width:INTEGER;
          tmp_width:=get_width rows;
          tmp:=tmp_width*(get_height rows);
          (tmp<area).if {
            area:=tmp;
            width_opt:=tmp_width;
          };
        };

        width_max:=width_max-widget_min_width;
        widgets_height:=get_height rows;
      };

      width_opt
  );

  - make_placement <-
  (
    +l:LINKED_LIST[LINKED_LIST[G_EXPR]];
    l:=widget_placement_from (widget_placement);

    l.foreach {
      i:LINKED_LIST[G_EXPR];
      +row:G_EXPR;

      i.foreach {
        g:G_EXPR;
        (row=NULL).if {
          row:=g;
        } else {
          row:=row | g;
        };
      };

      (placement=NULL).if {
        placement:=row;
      } else {
        placement:=placement / row;
      };
    };
  );

  - widget_placement_from width_opt:INTEGER : LINKED_LIST[LINKED_LIST[G_EXPR]]<-
  (
    +cur_width:INTEGER;
    +rows_opt:LINKED_LIST[LINKED_LIST[G_EXPR]];
    
    rows_opt:=LINKED_LIST[LINKED_LIST[G_EXPR]].create;
    rows_opt.add_first (LINKED_LIST[G_EXPR].create);
    root.list.foreach {
       node:INODE;
       cur_width:=cur_width+(node.content).width_min;
       (cur_width<width_opt).if {
         rows_opt.last.add_last (node.content);
       } else {
	 rows_opt.add_last (LINKED_LIST[G_EXPR].create);
         rows_opt.last.add_last (node.content);
	 cur_width:=(node.content).width_min;
       };
    };
    rows_opt
   );

  - affiche_list l:LINKED_LIST[LINKED_LIST[G_EXPR]] <-
  (
    l.foreach {
      i:LINKED_LIST[G_EXPR];
      i.foreach {
        j:G_EXPR;
        " | ".print;
      };
      "\n".print;
    };
  );

  - evaluation node:INODE <-
  (
    /*
     * GUII doit lancer l'évaluation de ses fils avec MENU_BAR, TOOL_BAR, et PAGE.
     * MENU_BAR lance l'évaluation de ses fils avec les pattern appropriés, idem pour
     * TOOL_BAR et PAGE. La faisabilité de MENU_BAR est calculée en fonction de la 
     * faisablité de ses fils qui elle-même est caluclée en fonction de celle des petits-fils,
     * et ainsi de suite.
     */


    node.list.foreach {
      i:INODE;
      +best_prc:REAL_32;
      +tmp:REAL_32;
      +parent:INTERNAL_INODE;

      (!i.list.is_empty).if {
        tmp:=MENU_BAR.evaluate i width screen_width height screen_height;"\n\n".print;
        (tmp>best_prc).if {
          best_prc:=tmp;
          parent:=MENU_BAR;
          "=================================================>MENU_BAR\n".print;
        };
        tmp:=MENU_V.evaluate i width screen_width height screen_height;"\n\n".print;
        (tmp>best_prc).if {
          best_prc:=tmp;
          parent:=MENU_V;
          "=================================================>MENU_V\n".print;
        };
        tmp:=MENU_H.evaluate i width screen_width height screen_height;"\n\n".print;
        (tmp>best_prc).if {
          best_prc:=tmp;
          parent:=MENU_H;
          "=================================================>MENU_H\n".print;
        };
        tmp:=DROP_DOWN_MENU.evaluate i width screen_width height screen_height;"\n\n".print;
        (tmp>best_prc).if {
          best_prc:=tmp;
          parent:=DROP_DOWN_MENU;
          "=================================================>DROP_DOWN_MENU\n".print;
        };
      } else {
        tmp:=CHECK.evaluate i width screen_width height screen_height;"\n\n".print;
        (tmp>best_prc).if {
          best_prc:=tmp;
          parent:=CHECK;
          "=================================================>CHECK\n".print;
        };
        tmp:=ACTION.evaluate i width screen_width height screen_height;"\n\n".print;
        (tmp>best_prc).if {
          best_prc:=tmp;
          parent:=ACTION;
          "=================================================>ACTION\n".print;
        };
        tmp:=PAGE.evaluate i width screen_width height screen_height;"\n\n".print;
        (tmp>best_prc).if {
          best_prc:=tmp;
          parent:=PAGE;
          "=================================================>PAGE\n".print;
        };
      };
      (best_prc=0).if {
        "No patterns match for ".print;i.name.print;"\n".print;
        OBJECT.die_with_code 1;
      } else {
        i.set_representation parent;
        i.name.print;"====================================================================================>".print;i.print;"\n".print;
        i.evaluate i width screen_width height screen_height;
        i.make_representation;
        screen_width:=screen_width-i.content.width_min;
        screen_height:=screen_height-i.content.height_min;
      };
    };
    root.display;
  );

